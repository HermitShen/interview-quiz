Tags: [[для собеседований]]

#golang 



## Планировщик



1. Зачем нужен отдельный планировщик?
   
	Для подобного вопроса на собесе используй заготовленный список ниже
	
	![[Screenshot From 2025-10-07 21-33-46.png]]
	
	
	В планировщие содержатся пулы для различных тяжеловесных структур и не только:
	
	- Пул потоков ОС
	- Пул логических процессоров
	- Пул горутин
	  
	Все эти структуры нам пересоздавать не обязательно
	
	Если нам нужен новый поток - мы не идем к ОС за выделением, а исопльзуем тот, что в пуле
	
	
	Кроме этого планировщик позволяет эффективно работать с **асинхронными syscall** - ми, в частности сетевыми вызовами за счет **netpoller**-а


---


2. Особенности планировщика

	Планировщик GO реализует **NxM планировщик**, т.е. такой, где **на определенное кол-во потоков ОС мапится какое-то кол-во горутин**
	
	Кол-во горутин может быть гораздо больше кол-ва потоков
	
	
	В рамках планировщика используется **GMP - модель**:
	
	- G - горутины (что исполняем)
	
	- M - где исполняется, по сути надстройка над потоком ОС
	  
	- P - "логическое ядро", это абстракция, которая **хранит очередь горутин одного потока и ресурсы** - различные кэши для потока
	
	![[Screenshot From 2025-10-08 01-20-24.png]]
	
	Чтобы уменьшить кол-во переключений контекста **по-умолчанию кол-во лог. ядер в GMP-модели равно кол-ву лог. ядер процессора**
	
	
	
	Кэшами в рамках лог. ядра P служат:
	
	- Кэш стека (stack cache)
	- Кэш кучи (malloc cache)
	- Другие кэши
	
	![[Screenshot From 2025-10-08 01-21-22.png]]
	
	Кэши лог. ядер - это оптимизация, позволяющиая аллокатору **не ходить в общую память процесса**, а **выделять ее в кэше**
	
	Без них каждый поток ждал бы остальные под мьютексом в очереди


---


3. Как новые горутины попадют в очередь? Как они выполняются?

	Изначально при старте программы у нас работает только горутина `main`, в которой непосредственно вызывается ф-ия `main`
	
	Ф-ия `main` запускается **вместе с планировщиком** 
	
	
	
	Новые горутины, порождаемые через `go` **из другой горутины**, приобретают  статус **ready** - т.е. готовый к работе - после назначения ее лог. процессору
	
	После этого они попадают в **локальную очередь**, соотв. потоку, в котором они были созданы
	
	![[Screenshot From 2025-10-08 02-09-42.png]]
	
	
	Как только горутина дошла до **точки выхода** - это может быть, например,  `wg.Wait()` - она сигнализирует планировщику, что ее можно снять с выполнения
	
	Она меняет статус с **Running** на **Waiting**
	
	После этого она снимается с выполнения, и вместо нее выполняется первая горутина из очереди
	
	![[Screenshot From 2025-10-08 02-14-59.png]]
	
	
	Когда все горутины из очереди отработали на потоке ОС, гогутина `main` меняет статус на **Ready**, попадает в ту же самую очередь и выполняется на том же потоке
	
	![[Screenshot From 2025-10-08 02-17-57.png]]
	
	
	Для нескольких потоков ОС все эти процессы повторяются так же
	
	![[Screenshot From 2025-10-08 02-20-03.png]]


> [!info]  
> В статусе **Waiting** у горутин есть причина остановки `waitReason`
> 
> Помимо упомянутой `wg.Wait()` есть еще 40+ значений
> 
> В зависимости от значения `waitReason` планировщик принимает решение, что делать с горутиной
> 
> Вот снэпшот некоторых других значений
> 
> ![[Screenshot From 2025-10-08 02-58-52.png]]
> 


---


4. Как потоки взаимодействуют друг с другом?

	Рано или поздно **в очереди могут закончиться горутины**
	
	Чтобы поток не простаивал, он может **взять из другой локальной очереди несколько горутин**
	
	Очередь, из которой будут красться горутины, выбирается **рандомно**
	
	
	
	Делает он это так: он берет **половину** горутин **с конца очереди**
	
	Именно половину, потому что нужна золотая середина, чтобы **не выполнить все сразу** и **оставить что-то** другой очереди
	
	![[Screenshot From 2025-10-08 02-32-24.png]]
	
	
	
	Помимо локальных очередей есть еще **глобальная очередь**
	
	Из нее потоки тоже могут горутины, но при одном из условий:
	 
	- В локальной очереди **нет горутин**
	  
	- Локальная очередь очень длинная - тогда **после каждой 61-й горутины** мы берем **по одной** из глобальной очереди
	  
	![[Screenshot From 2025-10-08 02-48-33.png]]


> [!hint] 
> Приоритетность поиска горутин для выполнения у процессора выглядит так
> 
> - Если в потоке есть горутины, то через каждые 60 горутин идем в глоб. очередь
> >
> - Берем след. горутины из локальной очереди
> >
> - Если в своей очереди ничего нет, идем брать у другой локальной очереди
> >
> - Только после этого идем в глобальную очередь 
> 


---


5. CS у горутин

	Переключение между горутинами - это **дешевая** операция
	
	Для смены контекста горутинам нужен саиый минимум: просто сохранение/загрузка пары регистров и смена стека; обычно **наносекунды–сотни наносекунд**.
	
	
	К тому же переключение не прерывает никаких расчетов:
	
	1.  Горутины переходят в состояние **waiting** по одной из нескольких причин из 
	 `waitReason`, например из-за мьютекса
	
	2. Потом мы ставим на выполнение следующую в очереди горутину
	
	3. После выполнение мьютекс разблокируется -> вытесненная горутина переходит из сотояния **waiting** в **ready** 
	   
	4. Она возвращается в очередь, небольшой контекст восстанавливается и горутина отрабатывает до конца
	   
	   
	Все это происходит **без переключения потоков и syscall-ов**


---


6. Синхронный syscall
   
	Когда горутине нужно выполнить syscall, сама она напрямую не может пойти в **kernel space** и выполнить код 
	 
	Это может сделать только **планировщик ОС**, который в свою очередь **ничего не значет о горутинах**, он управляет только **потоками ОС**
	
	Поэтому syscall из любой горутины в потоке - это CS в свой поток 
	
	**Поток** же во время syscall **блокируется**
	
	![[Screenshot From 2025-10-08 21-37-43.png]]
	
	
	
	Чтобы другие горутины **не голодали** из-за блокировки мы можем добавить оптимизации в зависимости от **конкретного** syscall
	
	Кол-во syscall в системе **не так много**, им можно даже присвоить индексы
	
	Поэтому компилятор может решить, какую инструкцию ему нужно выполнить **до и после выполнения** syscall
	
	
	
	Если syscall короткий, ты мы даем ему примерно **10мс** на выполнение
	
	Если syscall долгий, то идем по порядку:
	
	- Как только поток блокируется, он "открепляется" от очереди (по сути G, M, P - это **структуры, которые связаны ссылками**, как в связанном списке), т.е. стирает значение ссылки на другую структуру
	
	- После этого он создает новый поток ОС и закрепляет его на свою бывшую очередь, чтобы горутины дальше могли выполняться
	  
	- После создания нового потока старый просто выполняет syscall
	  
	Весь этот процесс называется **hand-off**
	
	![[Screenshot From 2025-10-08 21-27-38.png]]
	
	
	


---


7. Асинхронный syscall (netpoller)

	
	
	
	
	


---








## Related


