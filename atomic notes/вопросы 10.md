Tags: [[для собеседований]]

#golang 



## Планировщик



1. Зачем нужен отдельный планировщик?
   
	Для подобного вопроса на собесе используй заготовленный список ниже
	
	![[Screenshot From 2025-10-07 21-33-46.png]]
	
	
	В планировщие содержатся пулы для различных тяжеловесных структур и не только:
	
	- Пул потоков ОС
	- Пул логических процессоров
	- Пул горутин
	  
	Все эти структуры нам пересоздавать не обязательно
	
	Если нам нужен новый поток - мы не идем к ОС за выделением, а исопльзуем тот, что в пуле
	
	
	Кроме этого планировщик позволяет эффективно работать с **асинхронными syscall** - ми, в частности сетевыми вызовами за счет **netpoller**-а


---


2. Особенности планировщика

	Планировщик GO реализует **NxM планировщик**, т.е. такой, где **на определенное кол-во потоков ОС мапится какое-то кол-во горутин**
	
	Кол-во горутин может быть гораздо больше кол-ва потоков
	
	
	В рамках планировщика используется **GMP - модель**:
	
	- G - горутины (что исполняем)
	
	- M - где исполняется, по сути надстройка над потоком ОС
	  
	- P - "логическое ядро", это абстракция, которая **хранит очередь горутин одного потока и ресурсы** - различные кэши для потока
	
	![[Screenshot From 2025-10-08 01-20-24.png]]
	
	Чтобы уменьшить кол-во переключений контекста **по-умолчанию кол-во лог. ядер в GMP-модели равно кол-ву лог. ядер процессора**
	
	
	
	Кэшами в рамках лог. ядра P служат:
	
	- Кэш стека (stack cache)
	- Кэш кучи (malloc cache)
	- Другие кэши
	
	![[Screenshot From 2025-10-08 01-21-22.png]]
	
	Кэши лог. ядер - это оптимизация, позволяющиая аллокатору **не ходить в общую память процесса**, а **выделять ее в кэше**
	
	Без них каждый поток ждал бы остальные под мьютексом в очереди


---


3. Как новые горутины попадют в очередь? Как они выполняются?

	Изначально при старте программы у нас работает только горутина `main`, в которой непосредственно вызывается ф-ия `main`
	
	Ф-ия `main` запускается **вместе с планировщиком** 
	
	
	
	Новые горутины, порождаемые через `go` **из другой горутины**, приобретают  статус **ready** - т.е. готовый к работе - после назначения ее лог. процессору
	
	После этого они попадают в **локальную очередь**, соотв. потоку, в котором они были созданы
	
	![[Screenshot From 2025-10-08 02-09-42.png]]
	
	
	Как только горутина дошла до **точки выхода** - это может быть, например,  `wg.Wait()` - она сигнализирует планировщику, что ее можно снять с выполнения
	
	Она меняет статус с **Running** на **Waiting**
	
	После этого она снимается с выполнения, и вместо нее выполняется первая горутина из очереди
	
	![[Screenshot From 2025-10-08 02-14-59.png]]
	
	
	Когда все горутины из очереди отработали на потоке ОС, гогутина `main` меняет статус на **Ready**, попадает в ту же самую очередь и выполняется на том же потоке
	
	![[Screenshot From 2025-10-08 02-17-57.png]]
	
	
	Для нескольких потоков ОС все эти процессы повторяются так же
	
	![[Screenshot From 2025-10-08 02-20-03.png]]


---


4. Как потоки взаимодействую друг с другом?

	Рано или поздно **в очереди могут закончиться горутины**
	
	Чтобы поток не простаивал, он может **взять из другой очереди несколько горутин**
	
	
	Делает он это так: он берет **половину** горутин **с конца очереди**
	
	Именно половину, потому что сам процесс **проходит под мьютексом**: нужна золотая середина, чтобы н**е выполнить все сразу** и **оставить что-то** другой очереди
	
	![[Screenshot From 2025-10-08 02-32-24.png]]
	
	
	
	
	
	


---







---
## Related


