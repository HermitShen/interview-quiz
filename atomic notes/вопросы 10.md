Tags: [[для собеседований]]

#golang 



## Планировщик



1. Зачем нужен отдельный планировщик?
   
	Для подобного вопроса на собесе используй заготовленный список ниже
	
	![[Screenshot From 2025-10-07 21-33-46.png]]
	
	
	В планировщие содержатся пулы для различных тяжеловесных структур и не только:
	
	- Пул потоков ОС
	- Пул логических процессоров
	- Пул горутин
	  
	Все эти структуры нам пересоздавать не обязательно
	
	Если нам нужен новый поток - мы не идем к ОС за выделением, а исопльзуем тот, что в пуле
	
	
	Кроме этого планировщик позволяет эффективно работать с **асинхронными syscall** - ми, в частности сетевыми вызовами за счет **netpoller**-а


---


2. Особенности планировщика

	Планировщик GO реализует **NxM планировщик**, т.е. такой, где **на определенное кол-во потоков ОС мапится какое-то кол-во горутин**
	
	Кол-во горутин может быть гораздо больше кол-ва потоков
	
	
	В рамках планировщика используется **GMP - модель**:
	
	- G - горутины (что исполняем)
	
	- M - где исполняется, по сути надстройка над потоком ОС
	  
	- P - "логическое ядро", это абстракция, которая **хранит очередь горутин одного потока и ресурсы** - различные кэши для потока
	
	![[Screenshot From 2025-10-08 01-20-24.png]]
	
	Чтобы уменьшить кол-во переключений контекста **по-умолчанию кол-во лог. ядер в GMP-модели равно кол-ву лог. ядер процессора**
	
	
	
	Кэшами в рамках лог. ядра P служат:
	
	- Кэш стека (stack cache)
	- Кэш кучи (malloc cache)
	- Другие кэши
	
	![[Screenshot From 2025-10-08 01-21-22.png]]
	
	Кэши лог. ядер - это оптимизация, позволяющиая аллокатору **не ходить в общую память процесса**, а **выделять ее в кэше**
	
	Без них каждый поток ждал бы остальные под мьютексом в очереди


---


3. Как новые горутины попадют в очередь?

	Изначально при старте программы у нас работает только горутина `main`, в которой непосредственно вызывается ф-ия `main`
	
	Ф-ия `main` запускается **вместе с планировщиком** 
	
	
	Новые горутины, порождаемые через `go` **из другой горутины**, приобретают  статус **ready** - т.е. готовый к работе - после назначения ее лог. процессору
	
	Т.к. поток управляет горутинами только **в рамках своей очереди**, все новые горутины **попадют в локальную очередь, присвоенную соотв. лог. процессору**
	
	
	
	


---
## Related


