Tags: [[для собеседований]]

#golang 



# Пререквизиты
 

Для решения задач на слайс нужно держать в голове 3 факта:

- Как работает `append`

- Как расчитываются начальные `len` и `cap` слайса

- Слайс - это ссылочный тип

 

В рантайме слайс выглядит так

```go
type slice struct {
	array unsafe.Pointer
	len int
	cap int
}
```

 

Инициализироваться слайс можно с помощью литерала:

![[Screenshot From 2025-10-03 16-47-56.png]]

 

Все копии слайса указывают на тот же массив

![[Screenshot From 2025-10-03 17-02-44.png]]

 

Если `cap` превышен, то ссылка будет указывать на новый массив

Здесь `copy_of_a` будет выглядеть как `[1,2,3,4],0,0`, т.е. появятся нули как в случае с `make`

![[Screenshot From 2025-10-03 17-08-34.png]]

 

Если после `append` длина не превышает `cap`, но новый элемент ушел за длину, его не будет видно 

В таком случае надо реслайсить, чтобы увидеть изменения

```go
func main() {  
	s := make([]int, 3, 4)  // len=3, cap=4, [0,0,0,] 0]
	for i := range 3 {  // len=3, cap=4, [1,2,3,] 0]
	   s[i] = i + 1  
	}  
  
	changeSlice(s)  // len=3, cap=4, [1,2,3,] 4]
	s1 := s[:cap(s)]  // // len=4, cap=4, [1,2,3,4]
  
	fmt.Println(s)  
}  
  
func changeSlice(s []int) {  
	s = append(s, 4)  
}
```

 

Если мы наполняем слайс через `append` с нечетным кол-ом элементов, но от 3, то `cap` округлится вверх до четного числа

```go
func main() {  
    a := []int{}  
  
    a = append(a, []int{1, 2, 3, 4, 5}...) // len=5, cap=6 [1,2,3,4,5],0  
  
    fmt.Println("cap(a) = ", cap(a))  
  
    b := append(a, 6) // len=6, cap=6, [1,2,3,4,5,6]  
    c := append(a, 7) // len=7, cap=12, [1,2,3,4,5,7]  
  
    c[1] = 0 // len=7, cap=12, [1,0,3,4,5,7] 
  
    fmt.Println("a =", a)  // len=5, cap=6 [1,0,3,4,5],7 
    fmt.Println("b =", b)  // len=6, cap=6 [1,0,3,4,5,7]
    fmt.Println("c =", c)  // len=6, cap=6 [1,0,3,4,5,7]
}
// cap(a) =  6
// a = [1 0 3 4 5]
// b = [1 0 3 4 5 7]
// c = [1 0 3 4 5 7]
```

 

Когда мы берем подслайс от слайса, последний элемент в интервале **не включается**

```go
a := []int{1,2,3,4,5} // len=5, cap=5, [1,2,3,4,5]

b := a[2:4] // len=2, cap=3, [3,4],5
```

 

Как оставлять комментарии при решении задач со слайсами:

![[Screenshot From 2025-10-03 17-16-53.png]]

 
# Задачи


 

## Задача 1
  

```go
const MAX = 5  
  
func main() {  
	s := generate() // len=4, cap=5, [1,2,3,4],5  
	mutation(s)     // len=4, cap=5, s=[1,2,3,4],-1  
	fmt.Println("s=", s)  
	fmt.Println(s[0:MAX])  
}  
  
func generate() []int {  
	out := make([]int, 0, MAX)  
	for i := 1; i < MAX; i++ {  
	   out = append(out, i) // len=4, cap=5, [1,2,3,4],5  
	}  
	return out  
}  
  
func mutation(s []int) {  
	s = append(s, -1) // len=5, cap=5, [1,2,3,4,-1]; s=[1,2,3,4],-1  
}

// s= [1 2 3 4]
// [1 2 3 4 -1]
```

Обрати внимание на итоговый слайс `s` и его реслайс `s[0:MAX]`
 
## Задача 2
 

```go
	func main() {  
	s := make([]int, 0, 5) // len=0, cap=5, [],0,0,0,0,0  
	s = append(s, 1, 2, 3) // len=3, cap=5, [1,2,3],0,0  
  
	subSlice := s[1:3] // len=2, cap=4, [2,3],0,0  
  
	subSlice[0] = 99               // len=2, cap=4, [99,3],0,0; s=
	// [1,99,3],0,0  
	subSlice = append(subSlice, 4) // len=3, cap=4, [99,3,4],0; s=
	// [1,99,3],4,0  
  
	s = append(s, 5, 6, 7) // len=6, cap=10, new, [1,99,3,5,6,7]  
  
	subSlice[1] = 100 // len=3, cap=4, [99,100,4],0  
  
	fmt.Println("s:", s)               
	fmt.Println("subSlice:", subSlice) 
}
// [1,99,3,5,6,7] 
// [99,100,4]  
```

Это задача от нейросети, но на интервью могут такие встретиться
 

## Задача 3
 

```go
func modify(s []int, n int) {  
	s = append(s, n)  
	s[0] = 999  
}  
  
func main() {  
	s1 := make([]int, 3, 5)  
	s2 := s1[:2]  
  
	s1[0] = 1  
	s2[1] = 2  
  
	modify(s1, 55)  
	modify(s2, 66)  
  
	fmt.Println("s1:", s1)  
	fmt.Println("s2:", s2)  
	fmt.Println("s1 cap:", cap(s1), "s2 cap:", cap(s2))  
}
```

Самая сложная от нейросети, на собесе будут проще

 

## Задача 4 (на рефакторинг)
 

Нужно отрефакторить следующий код

```go
	func getBytes(start, end int) []byte {  
	arr := [999999999]byte{}  
  
	slice := arr[start:end] // len=10, cap=inf  
  
	return slice  
}  
  
func main() {  
	s := getBytes(10, 20)  
  
	println(cap(s))  
  
	fmt.Println(s)  
}
// 999999989
// [0 0 0 0 0 0 0 0 0 0]
```

 

Здесь мы тащим в `main` слайс, который ссылается на огромный массив (~1Гб)

Т.к. на него есть ссылка, он остается жить в куче

Поэтому мы хотим скопировать только нужные байты, а огромный массив сотрется после возврата ф-ии `getBytes`

```go
func getBytes(start, end int) []byte {  
	arr := [999999999]byte{}  
  
	slice := make([]byte, end-start) // len=10, cap=10  
	copy(slice, arr[start:end])  
  
	return slice  
}  
  
func main() {  
	s := getBytes(10, 20)  
  
	println(cap(s))  
  
	fmt.Println(s)  
}
// 10
// [0 0 0 0 0 0 0 0 0 0]
```

Теперь все правильно