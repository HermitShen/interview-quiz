Tags: [[для собеседований]]

#golang 



## Указатели (ссылки)



1. Что такое ссылка

	Ссылка - это такая же переменная, как и все остальные, хранящая адрес другой переменной в **виртуальной памяти (не физической!)**
	
	
	У ссылок так же есть **свой адрес**, который можно передать **другим переменным**
	
	Можно делать даже **ссылки на ссылки**, но это увеличит кол-во прыжков по памяти, когда нам захочется **разыменовать указатель**
	
	
	Адрес занимает **8 байт**
	
	 ![[Screenshot From 2025-10-02 09-31-24.png]]
	 Здесь переменная `c` хранит память переменной `a`


---


2. Передача по ссылке/значению

	Все всегда передается **по значению**, даже ссылки
	
	
	Чтобы мы могли **мутировать** переданную переменную, мы должны:
	
	- Передать копию **ссылки** на эту переменную
	- Обязательно **разыменовать ссылку** и присвоить новое значение
	
	
	Эти варианты мутировать переменную **не будут**
	```go
	type Address struct {
		  city string
		  street string
		  house int
	  }
	  
	func (a *Address) setCity(city string) {
		  a = &Address{
			  city: city,
		  }
	  }
	  
	  func setHouse(addr *Address, house int) {
		  addr = &Address{
			  house: house,
		  }
	  }
	```
	  
	А этот будет 
	```go
	func (a *Address) setStreet(street string) {
		a.street = street
	}
	```


> [!caution] 
> У **ссылочных типов данных** (map, slice, string, chan) всегда передается **ссылка на внутренние значения**
> 
> Поэтому они **всегда мутируются** при изменении 


---


3. Усложненная передача (`append`)

	`Append` **возвращает новый слайс** (c тем же или новым массивом)
	
	Если `cap` позволяет, то `append` вернет **копию того же слайса**, но с `len+1` и новым элементом
	
	Но если новое значение **превышает `len`** по индексу, но **не превышает `cap`**, то изменения в старом слайсе видны **не будут**
	
	Чтобы увидеть изменения в старом, нужно **реслайсить** его с длиной на 1 больше
	
	
	```go
	func main() {  
	    s := make([]int, 3, 4)  // len=3, cap=4, [0,0,0,] 0]
	    for i := range 3 {  // len=3, cap=4, [1,2,3,] 0]
	       s[i] = i + 1  
	    }  
	  
	    changeSlice(s)  // len=3, cap=4, [1,2,3,] 4]
	    s1 := s[:cap(s)]  // // len=4, cap=4, [1,2,3,4]
	  
	    fmt.Println(s)  
	}  
	  
	func changeSlice(s []int) {  
	    s = append(s, 4)  
	}
	```


---


4.  Возврат из ф-ии через `defer`

	Ф-ия возвращает **копию** переменной, которая указана после `return` 
	
	Т.е. это работает так же, как и передача в ф-ию.
	
	
	Поэтому через `defer` мы **не можем** поменять возвращаемую переменную, т.к. `defer` выполняется **после выхода из ф-ии**, но **до присвоения копии** в переменную
	
	
	Если мы хотим изменить возвращаемую копию, то мы должны **явно** на нее ссылаться
	
	Это делается с пом. **именованных возвратов**
	
	```go
		type Person struct {  
	    name string  
	    age  int  
	}  
	  
	func changeName(p *Person, name string) {  
	    p.name = name  
	}  
	  
	func getPerson() (p Person) {  
		//var p Person  -> так мы не поменяем 
		  
	    defer changeName(&p, "John")  
	  
	    p = Person{name: "Bob", age: 30}  
	  
	    return p  
	}  
	  
	func main() {  
	    p := getPerson()  
	  
	    fmt.Println(p)  
	}
	// {John 30}
	```


---


## Nill values



1. Инициализация с `nil`

	Если мы создаем ссылочные типы данных без `make` или пустые ф-ии, работать с ними **нельзя**:
	
	- `map` при записи выдаст `panic`
	
	- `chan` при чтении/записи **заблокирует горутину навсегда**
	
	- вызов пустой ф-ии выдаст `panic`
	
	- и др.
	
	
	Все подвохи в работе с `nil`-типами проиллюстрированы ниже
	  
	![[Screenshot From 2025-10-02 13-24-36.png]]


---
 

## Related


