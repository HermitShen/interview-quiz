Tags: [[для собеседований]]

#golang 



# Паттерны
 

## Fan-in
 

Условие выглядит так:

![[Screenshot From 2025-10-16 01-57-39.png]]
 

От нас хотят реализовать **один воркер**, который будет читать из **нескольких каналов**

Это часть большого паттерна **Fan-out_fan-in**
 

В идеале нужно укладываться **менее чем за 10 минут**
 

Возможная реализация ф-ии

```go
func fanin(ctx context.Context, chans ...<-chan int) <-chan int {  
    out := make(chan int)  
  
    go func() {  
       wg := &sync.WaitGroup{}  
       for _, ch := range chans {  
          wg.Add(1)  
          go func() {  
             for {  
                select {  
                case <-ctx.Done():  
                   return  
                case v, ok := <-ch:  
                   if !ok {  
                      return  
                   }  
                   select {  
                   case out <- v:  
                   case <-ctx.Done():  
                      return  
                   }  
                }             
            }    
        }()       
     }       
     wg.Wait()  
     close(out)  
  
    }()  
    
    return out  
}
```

Здесь был добавлен контекст с таймаутом, если попросят на собесе
 

Нюансы:

- Мы создаем канал `out` **двунаправленным**, потмоу что на выходе он автоматически конвертируется в read-only канал

- Если контекст не нужен, замени `select ` на обычный `range` по каналу
  
- Абсолютно весь код оберни в горутину **между созданием и возвратом канала** `out`
 

## Errgroup
 

На собеседовании могут попросить распараллелить какую-то работу с удаленным источником так, чтобы горутины возвращали ошибку

Ошибка должна отменять все остальные горутины в процессе

Оптимальным выбором будет не использовать свою реализацию с примитивами, а использовать метод `{go}errgroup.Go` из пакета `{go}"errgroup"`

 
Одна из возможных реализаций на примере конкуретной записи в in-memory хранилище

```go

```



