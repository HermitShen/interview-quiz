Tags: [[для собеседований]]

#golang 



## Пререквизиты



Все вопросы сводятся к следующему списку:

![[Screenshot From 2025-10-04 17-47-40.png]]



> [!info] 
> Интрерфейсы нужны для **уменьшения связанности кода** - лаконичное определение, если спросят



В рантайме интерфейс выглядит так

```go
type iface struct {
	tab *itab
	data unsafe.Pointer
}
```




> [!info]  
> В Go есть правило "method set" из спецификации.
> 
> Кратко:
> 
> - Тип `T` содержит только методы с получателем `T`.
> 
> - Тип `*T` содержит методы с получателем как `T`, так и `*T`.  
>   
>  Т.е. **ссылочный тип будет заимствовать те же методы, как и тип, на который он ссылается**
> 



> [!important] 
> **Type assertion** - это операция, доступная только для переменной типа `interface{}`
> 
> Если тип **удовлетворяет** интерфейсу, но им **не является**, компилятор **вызовет ошибку** 




Извлечение типа переменной в рантайме, а для этого и нужен type assertion, использует **рефлексию**

Любое **неправильное** толкование типа в таких случаях всегда **влечет панику**

Поэтому такие операции (type assertion, type switch) должны использовать флаг `ok`

```go
func main() {  
    var a interface{}  
    a = ab{}  
  
    a1, ok := a.(ABC)  
	if !ok {
		println("not ok")
	}
  
    fmt.Println(a1)  
}
```



## Задачи/вопросы



1. `Nil` vs `not-nil` интерфейс

	В рантайме GO интерфейс - это **структура с двумя полями ссылочного типом**
	
	Каждая ссылка в 64-битной системе весит 8байт
	
	Соответственно пустой интерфейс будет весить 16 байт (32 в 32-битной системе)
	
	
	Переменная типа `interface` будет равно `nil` только тогда, когда **обе ссылки равны `nil`**, т.е. нет не только **данных**, но и **информации о типе данных**
	
	
	Пример с известным типом
	
	```go
	func foo(a interface{}) {  
	    println(a == nil)  // false!
	}  
	  
	func main() {  
	    var a int  
	  
	    foo(a)  
	}
	```
	
	
	
	Если ф-ия возвращает тип `interface{}`, даже без значений, то переменная будет проходить проверку на `nil`
	
	Однако при выводе через `fmt.Println` возьмется **динамическое значение**
	
	```go
	type SomeStruct struct{}  
	  
	func foo() interface{} {  
	  
	    var result *SomeStruct  
	  
	    return result  
	}  
	  
	func main() {  
	    res := foo()  
	  
	    if res != nil {  
	       fmt.Println("res != nil! res =", res)  
	    }  
	}
	```


---


2. Задача на `error`

	```go
	type SomeError struct{}  
	  
	func (s SomeError) Error() string {  
	    return "some error"  
	}  
	  
	func foo() error {  
	  
	    var result *SomeError  
	  
	    return result  
	}  
	  
	func main() {  
	    result := foo()  
	  
	    if result != nil {  
	       fmt.Println("Error occured!!!", result)  
	       return  
	    }  
	}
	// Error occured!!! <nil>
	```
	
	Здесь из-за type definition мы возвращаем `interface{}` с ненулеым динамическим типом
	
	Мы ничего не присвоили в `result`, но как будто получили ошибку `error`
	
	
	Корректно объявлять `result` как интерфейс `error` и присваивать ему кастомную ошибку через `errors.New` или рез-т функции, которая возвращает `error`
	
	```go
	var SomeError = errors.New("some error")  
	  
	func foo() error {  
	  
	    var result error  
	  
	    result = SomeError  
	  
	    return result  
	}  
	  
	func main() {  
	    result := foo()  
	  
	    if result != nil {  
	       fmt.Println("Error occured!!!", result)  
	       return  
	    }  
	}
	// Error occured!!! some error
	```


---


3. type switch

	```go
	type ABC interface {  
	    A()  
	    B()  
	    C()  
	}  
	  
	type AB interface {  
	    A()  
	    B()  
	}  
	  
	type BC interface {  
	    B()  
	    C()  
	}  
	  
	type abc struct{}  
	  
	func (a abc) A() {}  
	func (a abc) B() {}  
	func (a abc) C() {}  
	  
	func main() {  
	    var a interface{}  
	  
	    a = abc{}  
	  
	    ab := a.(AB) // type = abc, interface=AB  
	  
	    ab.A()  // Можно
	  
	    bc := ab.(BC) // type = abc, interface=BC  
	    
	    bc.C()  // Можно
	  
	    abc1 := bc.(ABC) // type = abc, interface=ABC  
	  
		// Все ниже можно
	    abc1.A()  
	    abc1.B()  
	    abc1.C()  
	}
	```
	
	Обрати внимание, что в каждом из интерфейсом в `mail` хранится инф-я о **типе** `abc`
	
	Интерфейс лишь решает, какие методы **разрешены** для вызова на тип `abc`


---


4. Задача на type switch (дается в текстовом редакторе - без подсказок)

	```go
	func main() {  
	    var x = func() int { return 1 }  
	    x = nil  
	  
	    test(x)  
	}  
	  
	func test(x interface{}) {  
	    switch x.(type) {  
	    case int:  
	       fmt.Println("int", x)  
	    case string:  
	       fmt.Println("string", x)  
	    case nil:  
	       fmt.Println("nil", x)  
	    case func() int:  
	       fmt.Println("func", x())  
	    default:  
	       fmt.Println("unknown type")  
	    }
	}
	```
	
	Здесь идет проверка на понимание нескольких вещей:
	
	- У переменной `x` **есть тип**  `func() int`, присвоение `nil` лишь **меняет значение** (как и с любым литералом)
	  
	- `x.(type)` у интерфейса вызовется вернет `nil`, если **о типе ничего не известно**, но в нашем случае это не так
	  
	- `x()` - это не валидная запись, операция `()` работает только с ф-ей, **не интерфейсами**
	  
	- Ф-ию со значением `nil` вызывать **нельзя** - **вернется паника**
	
	
	
	Чтобы программа отработала, нужно **явно** сделать type assertion, чтобы можно было вызвать ф-ию
	
	```go
	 case func() int:  
		 f := x.(func() int)
	    fmt.Println("func", f()) 
	```
	
	А также убарть `x = nil` из `main`


---


5. Что такое интерфейс? Для чего он нужен?

	Интерфейс - это **абстракция** над стандартным типом
	
	Он описывает **контракт**, т.е. те методы, которые должен **реализовывать** тип, чтобы **удовлетворять** этому интерфейсу
	
	
	GO использует совокупность нескольких подходов из разных языков:
	
	- Duck typing (Python, JS, др. динамические языки) - для того, чтобы на лету менять реализацию зависимостей. Удобно для расширяемости приложения
	  
	- Явное указание зависимостей (Java, PHP) - для того, чтобы новые участники понимали, на какие зависимости опирается код. Удобно для онбординга новых участников разработки
	
	
	И интерфейсы реализуют обе эти идеи - они лишь требуют методы, но не конкретную реализацию. А сами интерфейсы можно передавать как зависимость.
	
	
	
	 Интрерфейсы позволяют **разорвать связь между зависимостями** или **уменьшить** ее (**decoupling**)


---


6. Где объявить интерфейс? 

	
	
	
	
	
	
	
	
	

## Related


