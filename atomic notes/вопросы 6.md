Tags: [[для собеседований]]

#golang 



## Интерфейсы



Все вопросы сводятся к следующему списку:

![[Screenshot From 2025-10-04 17-47-40.png]]



> [!info] 
> Интрерфейсы нужны для **уменьшения связанности кода** - лаконичное определение, если спросят



В рантайме интерфейс выглядит так

```go
type iface struct {
	tab *itab
	data unsafe.Pointer
}
```



> [!caution] 
> В Go есть правило "method set" из спецификации.
> 
> Кратко:
> 
> - Тип `T` содержит только методы с получателем `T`.
> 
> - Тип `*T` содержит методы с получателем как `T`, так и `*T`.  
>   
>  Т.е. **ссылочный тип будет заимствовать те же методы, как и тип, на который он ссылается**
> 



> [!caution] 
> **Type assertion** - это операция, доступная только для переменной типа `interface{}`
> 
> Если тип **удовлетворяет** интерфейсу, но им **не является**, компилятор **вызовет ошибку** 







> [!tip] 
> **Type assertion** можно использовать не только для проверки типа, но также и реализации им интерфейса
> 
> ```go
> // copyBuffer is the actual implementation of Copy and CopyBuffer.
> // if buf is nil, one is allocated.
> func copyBuffer(dst Writer, src Reader, buf []byte) (written int64, err error) {
> 	// If the reader has a WriteTo method, use it to do the copy.
> 	// Avoids an allocation and a copy.
> 	if wt, ok := src.(WriterTo); ok {
> 		return wt.WriteTo(dst)
> 	}
> 
> 	// Similarly, if the writer has a ReadFrom method, use it to do the 
> 	// copy.
> 	if rt, ok := dst.(ReaderFrom); ok {
> 		return rt.ReadFrom(src)
> 	}
> // 
> ``` 




1. `Nil` vs `not-nil` интерфейс

	В рантайме GO интерфейс - это **структура с двумя полями ссылочного типом**
	
	Каждая ссылка в 64-битной системе весит 8байт
	
	Соответственно пустой интерфейс будет весить 16 байт (32 в 32-битной системе)
	
	
	Переменная типа `interface` будет равно `nil` только тогда, когда **обе ссылки равны `nil`**, т.е. нет не только **данных**, но и **информации о типе данных**
	
	
	Пример с известным типом
	
	```go
	func foo(a interface{}) {  
	    println(a == nil)  // false!
	}  
	  
	func main() {  
	    var a int  
	  
	    foo(a)  
	}
	```
	
	
	
	Если ф-ия возвращает тип `interface{}`, даже без значений, то переменная будет проходить проверку на `nil`
	
	Однако при выводе через `fmt.Println` возьмется **динамическое значение**
	
	```go
	type SomeStruct struct{}  
	  
	func foo() interface{} {  
	  
	    var result *SomeStruct  
	  
	    return result  
	}  
	  
	func main() {  
	    res := foo()  
	  
	    if res != nil {  
	       fmt.Println("res != nil! res =", res)  
	    }  
	}
	```


---


2. Задача на `error`

	```go
	type SomeError struct{}  
	  
	func (s SomeError) Error() string {  
	    return "some error"  
	}  
	  
	func foo() error {  
	  
	    var result *SomeError  
	  
	    return result  
	}  
	  
	func main() {  
	    result := foo()  
	  
	    if result != nil {  
	       fmt.Println("Error occured!!!", result)  
	       return  
	    }  
	}
	// Error occured!!! <nil>
	```
	
	Здесь из-за type definition мы возвращаем `interface{}` с ненулеым динамическим типом
	
	Мы ничего не присвоили в `result`, но как будто получили ошибку `error`
	
	
	Корректно объявлять `result` как интерфейс `error` и присваивать ему кастомную ошибку через `errors.New` или рез-т функции, которая возвращает `error`
	
	```go
	var SomeError = errors.New("some error")  
	  
	func foo() error {  
	  
	    var result error  
	  
	    result = SomeError  
	  
	    return result  
	}  
	  
	func main() {  
	    result := foo()  
	  
	    if result != nil {  
	       fmt.Println("Error occured!!!", result)  
	       return  
	    }  
	}
	// Error occured!!! some error
	```


---


3. 

	
	
	
	
	
	






## Related


