Tags: [[для собеседований]]

#golang 



## Map



Все вопросы сводятся к следующему списку:

![[Screenshot From 2025-10-03 22-24-29.png]]



1. Устройство мапы, вставка по ключу

	В момент объявления мапы создаются структуры типа `bucket`, которые содержат набор из нескольких массивов ограниченной длины
	
	Т.е. после инициализации, например через `make`: 
	
	```go
	m := make(map[int]int)
	```
	
	Получается такая структура, в которой есть бакеты, а в каждом бакете - 3 массива по 8 элементов
	
	![[Screenshot From 2025-10-03 22-31-59.png]]
	
	
	
	Чтобы понять, в какой бакет положить `key-value` значение, мы прогоняем наше число через хэш-функцию
	
	Дальше мы ищем кол-во младших бит (`low-order bits`) результата хеш-ф-ии, оно равно **двоичному логарифму от кол-ва бакетов**
	
	Минимальный набор битов - 2 бита - позволяет положить число в 1 из 4 бакетов
	
	![[Screenshot From 2025-10-03 22-47-08.png]]
	
	
	
	После того, как определились с бакетом, мы заполняем все 3 массива
	
	В `tophash` пойдет старший бит значения хэш-ф-ии, а `key-value` - в соотв. им массивы
	
	![[Screenshot From 2025-10-03 22-50-04.png]]
	
	
	
	Для рационального хранения без лишних паддингов все ключи идут до значений
	
	Слева - реализация в мапе на 32-битной системе, а справа - антипример
	
	![[Screenshot From 2025-10-03 22-59-06.png]]


---


2. Как получается константная сложность у вставки?

	Каждая промежуточная операция для вставки в мапу делается за константное время:
	
	- Хэш-ф-ия генерирует хэш **определенной длины вне зависимости от размера ключа**
	  
	- Младшие биты из хэша берутся с пом. **побитовой операции** - тоже за константное время
	  
	- Взятие старшего байта от хеша - тоже константа
	  
	- Запись значений в массивы бакета - все за константное время
	
	![[Screenshot From 2025-10-04 14-03-31.png]]


---


3. Всегда ли будет константная сложность?

	Нет, в процессе заполнения мапы возможны **коллизии**
	
	Это когда все 8 элементов бакета заполнены, но новое значение нужно как-то сохранить
	
	Для этого у бакета есть ссылка `next *b` на новую ноду связанного списка, т.е. в **каждой ноде бакета будет по 3 массива на 8 элементов**
	
	![[Screenshot From 2025-10-04 14-12-15.png]]
	
	
	
	В худшем случае все элементы попадут в один бакет
	
	И тогда нам придется **последовательно перебирать весь связанный список** бакетов, а это сложность `O(n)`
	
	![[Screenshot From 2025-10-04 14-14-10.png]]


---


4. Поиск по ключу за константное время

	Все промежуточные операции поиска по ключу, как и во вставке, делаются за константное время
	
	- Взятие хеша
	  
	- Взятие младших битов
	  
	- Сюда добавляется поиск по `tophash` - старшему байту хэша. 
	
	
	
	`Tophash` состоит из 8 элементов, на 64-битной системе - это размер машинного слова (8 байт)
	
	А значит, запись в память займет **одну операцию** процессора
	
	Далее, если мы нашли среди них нужный байт - мы точно значем, что такой ключ есть в бакете, поэтому итерируемся по массиву ключей и ищем нужный 
	
	![[Screenshot From 2025-10-04 14-29-22.png]]
	
	Итерация по ключам и соотв. им значениям - это тоже константные операции, т.к. кол-во элементов, по которым мы итерируемся, **в худшем случае не меняется**, т.е. всегда O(8)
	
	Итого получаем следующее
	
	![[Screenshot From 2025-10-04 14-39-24.png]]


---


5. Что такое эвакуация данных и как она работает (либо прямой вопрос, либо через решение задачки на **взятие ссылки элемента мапы**)

	Чтобы избежать коллизий, была придумана эвакуация данных
	
	Она работает так: **если средний коэффициент заполненности бакетов равен `k=6.5`, все данных будут последовательно перенесены в новые бакеты**
	
	
	
	Примено такая заполненность будет считаться достаточной для эвакуации 
	
	![[Screenshot From 2025-10-04 14-53-52.png]]
	
	
	
	Все данные из старого бакета будут равномерно распределены по новым бакетам
	
	Добавиться параметр `evacuated`, который инкрементиться после эвакуации каждого бакета
	
	**Первыми эвакуируются самые старые бакеты**
	
	![[Screenshot From 2025-10-04 14-56-36.png]]
	


---


---


## Related


