Tags: [[для собеседований]]

#golang 



# Атомики


 


Популярные атомарные операции (для примера взят `Int32`, но актуально для других типов):

![[Screenshot From 2025-10-10 04-13-08.png|800]]

 


## Барьеры памяти (пререквизит к атомикам)

 


Ключевой механизм работы атомиков - исопльзование *барьеров памяти*

 


Компилятор в рамках оптимизации может изменить **порядок инструкций** программы, если **выполнение станет быстрее**

![[Screenshot From 2025-10-10 03-40-08.png|700]]

 


Этим в том числе может заниматься и CPU:

![[Screenshot From 2025-10-10 03-41-26.png|700]]

Причин для этого может быть много:

- Разное **время выполнение команд** процессором (деление, например, занимает в разы больше времени, чем инкремент)
  
- Длительные **походы в память** (вместо долгих походов делаем операции с короткими прыжками)

- **Инвалидация кэшей** (пока идет загрузка свежих данных из памяти сделаем другую операцию)

 
 


Чтобы **запретить переупорядочевание** и существуют барьеры

Они могут быть только на запись/чтение из памяти или смешанные 

![[Screenshot From 2025-10-10 03-50-16.png|800]]

 
 

## Как работают атомики?

 


В GO атомики используются смешанные барьеры памяти **acquire** и **release**, а также атомарные инструкции на уровне процессора

Атомарные инструкции **нельзя прервать**, а смешанные барьеры позволяют выполнять эти инструкции в **многопроцессорной среде**

 


Acquire: инструкции чтения и записи не могут прыгать **за барьер**

**Текущая горутина** получит самые свежие обновления **от других горутин**

![[Screenshot From 2025-10-10 03-57-59.png|700]]

 


Release: инструкции чтения и записи не могут прыгать **из барьера**

Все **другие горутины** получат свежие обновления **из текущей горутины**

![[Screenshot From 2025-10-10 03-59-38.png|700]]

 


Все атомарные операции используют оба барьера acquire и release друг за другом

Для примера взят `Load()`

![[Screenshot From 2025-10-10 04-18-45.png|300]]

 


Обычно в бенчмарках атомики быстрее мьюексов **в ~2 раза**, однако они все равно **накладывают доп. стоимость** и поэтому не являются панацеей

Стоимость связана с **частой инвалидацией кэшей** из-за того, что кэши всех ядер должны иметь одинаковое представление об атомике

Это можно частично решить доп. паддингом в кэш-линиях, чтобы **у каждого счетчика была своя кэш линия**


 
