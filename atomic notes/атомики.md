Tags: [[для собеседований]]

#golang 



## Атомики



1. Барьеры памяти (пререквизит к атомикам)

	Ключевой механизм работы атомиков - исопльзование **барьеров памяти**
	
	
	Компилятор в рамках оптимизации может переупорядочить **порядок инструкций** программы, если **выполнение станет быстрее**
	
	![[Screenshot From 2025-10-10 03-40-08.png]]
	
	
	Этим в том числе может заниматься и CPU
	
	![[Screenshot From 2025-10-10 03-41-26.png]]
	
	Причин для этого может быть много:
	
	- Разное **время выполнение команд** процессором (деление, например, занимает в разы больше времени, чем инкремент)
	  
	- Длительные **походы в память** (вместо долгих походов делаем операции с короткими прыжками)
	
	- **Инвалидация кэшей** (пока идет загрузка свежих данных из памяти сделаем другую операцию)
	
	
	
	Чтобы **запретить переупорядочевание** и существуют барьеры
	
	Они могут быть только на запись/чтение из памяти или смешанные 
	
	![[Screenshot From 2025-10-10 03-50-16.png]]


---


2. Как работают атомики?

	В GO атомики используются смешанные барьеры памяти **acquire** и **release**, а также атомарные инструкции на уровне процессора
	
	Атомарные инструкции **нельзя прервать**, а смешанные барьеры позволяют выполнять эти инструкции в **многопроцессорной среде**
	
	
	
	Acquire: инструкции чтения и записи не могут прыгать **за барьер**
	
	**Текущая горутина** получит самые свежие обновления от других горутин
	
	![[Screenshot From 2025-10-10 03-57-59.png]]
	
	
	
	Release: инструкции чтения и записи не могут прыгать **из барьера**
	
	Все **другие горутины** получат свежие обновления из текущей горутины
	
	![[Screenshot From 2025-10-10 03-59-38.png]]
	
	
	
	Популярные атомарные операции (для примера взят `Int32`, но актуально для других типов):
	
	![[Screenshot From 2025-10-10 04-13-08.png]]
	
	
	
	`Load()` использует барьер acquire


---


## Related


