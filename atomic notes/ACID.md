Tags:

#golang 



# ACID
 
## RDBMS vs NoSQL
 
Самым простой ответ: **NoSQL лучше масштабируется**

Однако он неоднозначный: реляционные бд постепенно догоняют по масштабируемости и простоте использования нереляционные, но в основном это касается больших компаний
 
 
Более компромисный ответ: **NoSQL не предоставляют гарантии ACID**

Хотя у них и есть свои отдельные гарантии BASE, они не подходят под определенные типы приложений
 
 
## Какие проблемы решает ACID?

 
A.C.I.D. - это **гарантии**, предоставляемые реляционными бд **из коробки**
 

Какие из проблем они покрывают:

![[Screenshot From 2025-10-20 10-21-11.png]]
 
 

## Атомарность (**A**CID)
 
Простое определение: это гарантия того, что будут выполнены либо все операции в рамках транзакции, либо не выполнилась ни одна
 

Более подробное объяснение: атомарность транзакций позволяет нам не реализовывать логику отката для каждой из операций

Бд за нас выполнит эту логику, нам лишь нужно вызывать ф-ию `{go}Rollback()`

![[Screenshot From 2025-10-20 10-37-25.png|450]]
![[Screenshot From 2025-10-20 10-37-52 1.png|450]]
 
 

## Согласованность (A**C**ID)
 
Все, что относится к **constraints** в бд, предоставляет эту гарантию

![[Screenshot From 2025-10-20 10-56-48.png|400]]
  

Если приводить в пример внешние ключи, то СУБД не позволит вставить новую запись в зависимую от другой таблицу, если такого отношения не сущ-т

```sql
-- Нельзя создать order на несуществующего клиента:
INSERT INTO orders(id, customer_id) VALUES (1, 42);  -- ошибка: FK нарушен

-- Нельзя удалить клиента, если на него ссылаются заказы (если нет CASCADE):
DELETE FROM customers WHERE id = 42;  -- ошибка: FK нарушен

```
 
 
 В отличие от атомарности **за согласованность отвечает приложение** (разработчик должен прописать все ограничения сам, чтобы они работали)
 
За примером с внешним ключом может пойти другой вопрос: **а всегда ли он нужен?**

![[Screenshot From 2025-10-20 11-12-53.png]]
 
> [!tldr] 
> В целом в хайлоад проектах от внешних ключей **стараются отказываться** 

 
 
## Изоляция (AC**I**D)
 
СУБД **из коробки** позволяет нескольким транзакциям работать с записями в БД **конкурентно**

Они **не могут** получать доступ к одним и тем же записям **одновременно**
 

В стандартах SQL есть 4 уровня изоляции транзакций, которые покрывают разное кол-во **аномалий**

У PostgreSQL, самой популярной БД в GO - коммьюнити, есть свои особенности, касающиеся аномалий: 

![[Screenshot From 2025-10-20 11-25-53.png]]
 
 
### Грязное чтение
  
Условие для возникновения: обе транзакции работают с одной записью; одна читает их, другая обновляет

Исход: если обновление коммитится раньше -> чтение откатывается из-за неконсистентности данных

![[Screenshot From 2025-10-20 11-50-32.png]]
 
### Неповторяющееся чтение
 
Условие для возникновения: одна транзакция читает те же данные несколько раз, другая - обновляет их между чтениями первой

Исход: читающая транзакция сначала вернет старое значение, а потом новое

![[Screenshot From 2025-10-20 11-49-37.png]]
 
### Фантомное чтение
 
Условие для возникновения: одна транзакция читает **несколько** записей, другая - меняет одну или несколько

Исход: читающая транзакция получает разное кол-во записей в обоих чтениях

![[Screenshot From 2025-10-20 11-56-04.png]]
 
### Уровень изоляции Serializable
 
Это самый строгий уровень изоляции - он **блокирует все операции** с таблицей для других операций

Если более точно: он **моделирует** ситуацию, будто параллельные транзакции выполняются последовательно друг за другом

 
Если при **разном порядке** вызова транзакций рез-т меняется, то часть транзакций **откатывается**

![[Screenshot From 2025-10-20 12-17-48.png]]
 
 
## Надежность (ACI**D**)
 
Какие случаи покрывает эта гарантия, а какие - нет:

![[Screenshot From 2025-10-20 12-25-53.png]]
 
