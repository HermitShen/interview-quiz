Tags: [[для собеседований]]

#golang 



# Процессы и поток ОС
---

&emsp;

Бенчмарк переключения контекста без использования горутин:

![[Screenshot From 2025-10-07 05-49-49.png]]

&emsp;

## Что такое процесс?
---
&emsp;

Процесс - это **абстракция**, содержащая **всю информацию о запущенной программе**.

Она нужна для того, чтобы планировщик ОС мог следить за множеством запущенных программ


Программа становится процессом в несколько этапов:

- Программа с помощью **комплилятора** приводится к **исполняемому коду** - **бинарному представлению кода** на каком-либо высокоуровневом ЯП
  
- Программа запускается - скомпилированный код загружается в RAM и CPU начинает выполнять **инструкции** с нужного entrypoint-а

&emsp;

У программы есть:

- **Независимое адресное пространство** - другие процессы не могут писать в/читать из другого
  
- Дескрипторы ресурсов и др.

![[Screenshot From 2025-10-07 02-26-54.png]]

&emsp;

Бинарник программы загружается в RAM **сегментами**:

![[Screenshot From 2025-10-07 02-30-09.png]]


`Text` сегмент - здесь хранится скомпилированный код программы, он доступен **только для чтения** (`Read-only`)


`Data/BSS` сегмент - иниц./неиниц. глобальные переменные, а также данные, подгружаемые с диска вместе с запуском программы


`Heap` - куча - место для переменных, которые должны **переживать вызов ф-ий**


`Stack` - выделенная для каждого **потока исполнения** память

&emsp;

У каждого стека есть свой **stack-pointer** (SP), локальные переменные, **адреса возвратов** и прочее

Размер каждого стека - **до 8Мб**

&emsp;

## Как процессор выполняет инструкции процесса?
---
&emsp;

В сегменте `text` хранятся в бинарном виде инструкции для процессора

&emsp;

Как выглядит цикл работы CPU по инструкциям:

- CPU берет адрес **первой инструкции** (в дальнейшем он просто будет делать вечный цикл по инструкциям) из регистра IP **(instruction pointer)**, который ядро CPU в начале запуска приложения заполнило
  
- Читает байты инструкции из памяти по этому адресу, при этом адрес **виртуальной памяти** транслируется на адрес **физический**, а все соответствия сохраняет в **TLB буфер**
 
 &emsp;

![[Screenshot From 2025-10-07 04-31-45.png]]

&emsp;

- Физический адрес инструкции читается в кэш процессора кэш-линиями

- Инструкции **декодируются**, параллельно лежа в IR (**instruction registry**) - аналоге **буфера**. Декодирование нужно, чтобы понять, **что за операция и какие операнды** (какие регистры/память).

- Выполняем инструкцию, это может быть **чтение в регистры**, **выполнение операций** или **запись рез-та в регистры/память**

&emsp;

![[Screenshot From 2025-10-07 04-53-51.png]]

&emsp;

Если планировщик решит переключиться на другой процесс, все регистры **сбрасываются** и заполняются уже новыми значениями из другой программы

![[Screenshot From 2025-10-07 04-58-56.png]]

&emsp;

Для переключения контекста между процессами в каждом процессе хранится структура `task_struct` с **сохраненными регистрами**, **указателем на адресное пространство** и др.

У каждого процесса (и потока) свой `task_struct`

![[Screenshot From 2025-10-07 05-01-16.png]]

&emsp;

## Что такое поток? Чем отличается от процесса?
---
&emsp;

В некоторых случаях ОС нужны дополнительные потоки исполнения для **многозадачности** или уменьшения простаивания 

&emsp;

Вместо одного потока на процесс можно выделить сразу несколько, и каждый из них будет хранить информацию **только о контексте** (набор регистров и стек)

Внутри одного процесса все потоки будут шерить соотв. **общее адресное пространство**, **исполняемый код** из сегмента `text`

![[Screenshot From 2025-10-07 05-39-05.png]]

&emsp;

Одно из полезных применений потоков - **отсутствие простаиваний** во время работы с I/O, сетевыми вызовыми и др. **блокирующими** процессами

Пока один поток ожидает, планировщик ОС может **переключить контекст на другой поток**, выполняя остальные инструкции процесса

&emsp;

Ключевые различия потока и процесса:

![[Screenshot From 2025-10-07 05-27-58.png]]

&emsp;

## Когда переключается контекст между потоками?
---
&emsp;

В линуксе реализована **вытесняющая многозадачность** - решение о переключении потока на другой **принимается операционной системой**, а не активным потоком

&emsp;

Переключение принимается в след. случаях:

- По таймауту 
  
![[Screenshot From 2025-10-07 05-57-42.png]]

&emsp;

- Блокирующий системный вызов 

	Мы не можем вызвать код внутри ОС из приложения, для этого нужны `syscall`-ы
	
	`syscall` - это переключение из потока процесса в поток ядра, выполнение кода ядра и повторное переключение обратно в прежний поток (2 переключения контекста)
	 

![[Screenshot From 2025-10-07 05-58-30.png]]

&emsp;

- Примитивы синхронизации 

![[Screenshot From 2025-10-07 06-02-53.png]]

&emsp;

- Прерывание
  
![[Screenshot From 2025-10-07 06-04-45.png]]


&emsp;

> [!important] 
> Уделяй отдельное внимание обработке прерываний 
> 
> ![[Screenshot From 2025-10-07 06-09-00.png]] 
> 

&emsp;

## Какие затраты есть у переключения контекста
---
&emsp;

**context switching** - не бесплатная операция, требующая промежуточных операций:

![[Screenshot From 2025-10-07 06-13-01.png]]

Для него нужна **сохранить все регистры на стек потока**, а при возвращении к этому же потоку **восстановить их**

В TLB буфере могут перезаписаться адреса с другого процесса

**Адреса** в кэше могут быть изменены

&emsp;

**Самый медленный фактор** - это **сохранение и восстановление регистров**


