Tags: [[для собеседований]]

#golang 





## 1. Слайсы: передача в функции и append
 

### Исходный код:

```go
func main() {
    si := make([]string, 5, 7) 
    f1(si)
    fmt.Println(si) 
}

func f1(si []string) {
    si = append(si, "Hello World!") 
}
```

### Вывод:

text

[     ]

(5 пустых строк, разделенных пробелами)

### Объяснение:

-   `{go}make([]string, 5, 7)` создает слайс с **длиной 5** и **емкостью 7**

-   При передаче в функцию `f1` передается **копия структуры слайса** (header)

-   `append` добавляет элемент за пределами исходной длины, изменяя локальную копию

-   Оригинальный слайс в `main` остается неизменным


### Как вывести с добавленным элементом:

`{go}si = si[:6]`  // расширяем длину до 6, чтобы включить добавленный элемент
`{go}fmt.Println(si)`

 
## 2. Преобразование slice интерфейсов
 

### Можно ли так делать?

```go
func f1(sl []Stringer) {
}

func main() {
    times := []time.Time{time.Now(), time.Now()}
    f1(times)  // ОШИБКА компиляции!
}
```

### Ответ: Нельзя

Нельзя напрямую преобразовать `[]time.Time` в `[]Stringer`, даже если `time.Time` реализует `Stringer`.

### Правильное решение:

```go
func main() {
    times := []time.Time{time.Now(), time.Now()}
    
    // Создаем слайс интерфейсов и заполняем в цикле
    stringers := make([]Stringer, len(times))
    for i, t := range times {
        stringers[i] = t 
    }
    
    f1(stringers)
}
```

 

## 3. Механизм работы горутин с каналами
 

### Вопрос:

Каким образом горутина, ожидающая чтения из канала, понимает, что можно продолжить работу?

### Ответ:

-   Горутина, которая **записывает** в канал, сообщает **планировщику** (scheduler) Go, что есть ожидающая горутина

-   Планировщик **будит** заблокированную горутину и переводит ее в состояние "готово к выполнению"

-   Это происходит через **runtime-механизмы** планировщика, а не через явные сигналы между горутинами

 

## 4. Ревью кода: обработка JSON
 

### Исходный код с проблемами:

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
    "strings"
)

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func main() {
    reqBody := `{"name":"Alice","email":"alice@example.com","age":30}`
    
    // ПРОБЛЕМА: игнорирование ошибок
    req, _ := http.NewRequest("POST", "http://example.com", strings.NewReader(reqBody))
    
    // ПРОБЛЕМА: nil pointer
    var user *User
    if err := json.NewDecoder(req.Body).Decode(user); err != nil {
        fmt.Println("Decode error:", err)
        return
    }
    
    fmt.Printf("Parsed user: %+v\n", user)
}
```

 

### Исправления:
#### 1. Обработка ошибок:

```go
req, err := http.NewRequest("POST", "http://example.com", strings.NewReader(reqBody))
if err != nil {
    fmt.Println("Request error:", err)
    return
}
```
 

#### 2. Инициализация указателя (варианты)

```go
// Вариант 1: Указатель на созданную структуру
var user *User = &User{}
if err := json.NewDecoder(req.Body).Decode(user); err != nil {
    // обработка ошибки
}

// Вариант 2: Значение + передача указателя
var user User
if err := json.NewDecoder(req.Body).Decode(&user); err != nil {
    // обработка ошибки
}

// Вариант 3: Использование new()
user := new(User)
if err := json.NewDecoder(req.Body).Decode(user); err != nil {
    // обработка ошибки
}
```
 

#### 3. Дополнительные улучшения:
/

**Конструктор:**

```go
func NewUser(name, email string, age int) *User {
    return &User{
        Name:  name,
        Email: email,
        Age:   age,
    }
}
```
 

**Интерфейс:**

```go
type UserService interface {
    ParseUser(r *http.Request) (*User, error)
    Validate() error
}

func (u *User) Validate() error {
    if u.Name == "" {
        return fmt.Errorf("name is required")
    }
    if u.Age < 0 {
        return fmt.Errorf("age cannot be negative")
    }
    return nil
}
```
 

## 5. Размещение констант в Go
 

### Вопрос:

Где размещаются константы?

### Ответ:

Константы в Go **встраиваются** (inline) непосредственно в бинарный код во время компиляции. Они не занимают память во время выполнения и не имеют адреса в памяти.

### Особенности:

-   Константы вычисляются на этапе компиляции

-   Нельзя получить указатель на константу (`{go}&myConst` - ошибка)

-   Заменяются непосредственными значениями в скомпилированном коде
 
- В бинарном коде мат. константы заменяются на числовые аналоги
  
   `{go}const Pi = 3.14159`



 
