Tags: [[для собеседований]]

#golang 



## Каналы



1. Как устроен канал?

	В рантайме канал (и с буфером, и без) выглядит так:
	
	![[Screenshot From 2025-10-12 23-53-05.png]]
	
	Т.е. любая переменная типа `chan` - это ссылка на эту структуру
	
	И у каждого канала своя копия
	
	
	
	Каждый из полей по-порядку: 
	
	- `closed` - атомарный флаг - закрыт или открыт канал
	  
		Флаг `closed` выбран не `bool`, потому что атомики не могут работать с `bool` параметрами
	
	
	- `recvq`, `sendq` - указатели на связанный список из горутин, которые ожидают чтения или записи
	
	
	- `lock` - мьютекс, нужен для защиты всего вн. состояния канала. Без него операции `send`/`recv`/`close` и конструкция `select` будут работать с гонками.
	
	
	- `buf` - **кольцевой буфер** с семантикой FIFO (т.е. это **очередь**, но после выхода за предельный индекс указатель сбрасывается до нуля)
	  
	  
		С ним связано большинство полей структуры:
		
		`recvx`, `sendx` - это индексы самого буфера для чтения, записи соответственно
		
		После чтения или записи индексы соответствующе будут декрементится/инкрементится
		
		Остальные поля понятны из названия полей структуры


---


2. Как работает буфер?

	Когда буферизированный канал пуст, указатели `recvq` и `sendq` указывают на начальный индекс буфера
	
	
	
	Когда мы пишем в канал, счетчик `sendx` инкрементится до тех пор, пока не дойдем до конца
	
	Если стоим в конце - обнуляем счетчик
	
	![[Screenshot From 2025-10-13 00-32-07.png]]
	
	![[Screenshot From 2025-10-13 00-34-06.png]]
	
	
	Значение запишется только если ячейка **пустая**
	
	Если горутина дальше пишет в переполненный буфер, она **блокируется**
	
	Планирощвик переводит горутину в состояние **waiting** и отвязывает от потока ОС, чтобы другие лог. процессоры не смогли ее забрать себе
	
	Чтобы потом "разбудить" ее и поставить в локальную очередь, ссылка на нее будет храниться в очереди `sendq`
	
	
	
	Когда мы читаем из канала, счетчик `recvx` расчитывается так же, как и `sendx`, счетчик обнуляется после лимита
	
	![[Screenshot From 2025-10-13 02-23-52.png]]
	
	Если в `sendq` после чтения была горутина, планировщик переведет ее статус **ready** и положит в конце локальной очереди
	
	
	
	Если горутина пытается читать из пустого канала, она попадает в `recvq` по аналогии с `senq`
	
	Когда придет пишущая горутина, она **не будет** писать значение в ячейку буфера, а **напрямую запишет его в структуру другой горутины**
	
	
	
	**Каждая операция записи/чтения защищена мьютексом**


---


3. Канал с буфером vs без буфера

	Без буфера горутины будут всегда передавать друг другу значение **напрямую**, без посредника по аналогии с чтением пустого канала
	
	![[Screenshot From 2025-10-13 03-00-34.png]]


---


## Related


