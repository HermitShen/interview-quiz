Tags: [[для собеседований]]

#golang 



## Процессы и поток ОС



Бенчмарк переключения контекста без использования горутин:

![[Screenshot From 2025-10-07 05-49-49.png]]



1. Что такое процесс?

	Процесс - это **абстракция**, содержащая **всю информацию о запущенной программе**.
	
	Она нужна для того, чтобы планировщик ОС мог следить за множеством запущенных программ
	
	
	Программа становится процессом в несколько этапов:
	
	- Программа с помощью **комплилятора** приводится к **исполняемому коду** - **бинарному представлению кода** на каком-либо высокоуровневом ЯП
	  
	- Программа запускается - скомпилированный код загружается в RAM и CPU начинает выполнять **инструкции** с нужного entrypoint-а
	
	
	
	У программы есть:
	
	- **Независимое адресное пространство** - другие процессы не могут писать в/читать из другого
	  
	- Дескрипторы ресурсов и др.
	
	![[Screenshot From 2025-10-07 02-26-54.png]]
	
	
	
	Бинарник программы загружается в RAM **сегментами**:
	
	![[Screenshot From 2025-10-07 02-30-09.png]]
	
	
	`Text` сегмент - здесь хранится скомпилированный код программы, он доступен **только для чтения** (`Read-only`)
	
	
	`Data/BSS` сегмент - иниц./неиниц. глобальные переменные, а также данные, подгружаемые с диска вместе с запуском программы
	
	
	`Heap` - куча - место для переменных, которые должны **переживать вызов ф-ий**
	
	
	`Stack` - выделенная для каждого **потока исполнения** память
	
	У каждого стека есть свой **stack-pointer** (SP), локальные переменные, **адреса возвратов** и прочее
	
	Размер каждого стека - **до 8Мб**


---


2. Как процессор выполняет инструкции процесса?

	В сегменте `text` хранятся в бинарном виде инструкции для процессора
	
	
	Как выглядит цикл работы CPU по инструкциям:
	
	- CPU берет адрес **первой инструкции** (в дальнейшем он просто будет делать вечный цикл по инструкциям) из регистра IP **(instruction pointer)**, который ядро CPU в начале запуска приложения заполнило
	  
	- Читает байты инструкции из памяти по этому адресу, при этом адрес **виртуальной памяти** транслируется на адрес **физический**, а все соответствия сохраняет в **TLB буфер**
	 
	![[Screenshot From 2025-10-07 04-31-45.png]]
	
	- Физический адрес инструкции читаетсяся в кэш процессора кэш-линиями
	
	- Инструкции **декодируются**, параллельно лежа в IR (**instruction registry**) - аналоге **буфера**. Декодирование нужно, чтобы понять, **что за операция и какие операнды** (какие регистры/память).
	
	- Выполняем инструкцию, это может быть **чтение в регистры**, **выполнение операций** или **запись рез-та в регистры/память**
	
	![[Screenshot From 2025-10-07 04-53-51.png]]
	
	
	
	Если планировщик решит переключиться на другой процесс, все регистры **сбрасываются** и заполняются уже новыми значениями из другой программы
	
	![[Screenshot From 2025-10-07 04-58-56.png]]
	
	
	
	Для переключения контекста между процессами в каждом процессе хранится структура `task_struct` с **сохраненными регистрами**, **указателем на адресное пространство** и др.
	
	У каждого процесса (и потока) свой `task_struct`
	
	![[Screenshot From 2025-10-07 05-01-16.png]]


---


3. Что такое поток? Чем отличается от процесса?

	В некоторых случаях ОС нужны дополнительные потоки исполнения для **многозадачности** или уменьшения простаивания 
	
	
	Вместо одного потока на процесс можно выделить сразу несколько, и каждый из них будет хранить информацию **только о контексте** (набор регистров и стек)
	
	Внутри одного процесса все потоки будут шерить соотв. **общее адресное пространство**, **исполняемый код** из сегмента `text`
	
	![[Screenshot From 2025-10-07 05-39-05.png]]
	
	Одно из полезных применений потоков - **отсутствие простаиваний** во время работы с I/O, сетевыми вызовыми и др. **блокирующими** процессами
	
	Пока один поток ожидает, планировщик ОС может **переключить контекст на другой поток**, выполняя остальные инструкции процесса
	
	
	
	Ключевые различия потока и процесса:
	
	![[Screenshot From 2025-10-07 05-27-58.png]]


---


4. Когда переключается контекст между потоками?

	
	
	
	


---


## Related


