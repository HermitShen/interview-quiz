Tags: [[для собеседований]]

#golang 



## String



Все символы из таблицы ASCII, а в нем есть **вся латиница**, кодируются **1 байтом**

Т.е. все символы, которые умещаются в числовое представление до 255, занимают **1 ячейку памяти**

Все символы после этого числа занимают **2+ байт**

![[Screenshot From 2025-10-06 12-55-26.png]]



Чтобы понимать, для каких символов используется ячейка памяти - однобайтовых или многобайтовых символов - используют **флажки** в виде **старших битов памяти**

У однобайтовых символов в старший бит кодируют `0`

У двубайтовых:

- Если это ведущий байт - в 3 старших бита кодируют `110`

- Если ведомый - в 2 бита кладут `10`

![[Screenshot From 2025-10-06 13-04-36.png]]



Для еще более больших символов логика повторяется, добавляется лишь по `1` в старшие биты ведущих байтов

Такая логика лежит в основе кодировки **UTF-8**

![[Screenshot From 2025-10-06 13-07-59.png]]



> [!caution] 
> Длина строки = кол-во байт в ней 



В зависимости от форматирования байт будет представлен по-разному:

```go
func main() {  
    greetings := "привет как дела"  
  
    fmt.Println(len(greetings))  // пробел занимает 1 байт
  
    fmt.Printf("%v %b %c \n", greetings[1], greetings[1], greetings[1])  
}
// 28
// 191 10111111 ¿ 
```




1. Как работать со строкой посимвольно?

	Для ASCII симовлов ничего не изменится - они будут выводится корректно и при побайтовой итерации, и при посимвольной
	
	Для остальных символов есть спец. тип - `rune`, являющийся элиасом для `int32`
	
	
	Чтобы работать посимвольно со строкой, нужно каждый байт строки привести к типу `rune`
	
	Тогда все числовые представления уместятся в одну переменную
	
	Это можно делать 2 путями:
	
	- Через цикл `range` - он автоматически делает конвертацию за нас
	  
	- Вручную через приведение типов
	  
	```go
	
	```
	
	
	

---


## Related


