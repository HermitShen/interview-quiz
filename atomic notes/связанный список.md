Tags: [[для собеседований]]

#golang 



# Связанный список



Готовая структура дли списков есть в [[структуры данных]]

Популярными методами решений являются

- Хеш-таблица

- Быстрый и медленный указатель

-  Dummy Node (Фиктивный узел)


Шаблон для создания и добавления нод в связанный список

```go
type ListNode struct {  
    Val  int  
    Next *ListNode  
}  
  
func NewListNode(val int) *ListNode {  
    return &ListNode{  
       Val:  val,  
       Next: nil,  
    }}  
  
type SinglyLinkedList struct {  
    Head, Tail *ListNode  
}  
  
func NewSinglyLinkedList() *SinglyLinkedList {  
    node := NewListNode(-1)  
    return &SinglyLinkedList{  
       Head: node,  
       Tail: node,  
    }}  
  
func (s *SinglyLinkedList) InsertEnd(val int) {  
    s.Tail.Next = NewListNode(val)  
    s.Tail = s.Tail.Next  
}  
  
Конец шаблона
```



---


## **LeetCode 19** [Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)


Задача на удаление n-ой с конца ноды из списка

После удаления нужно вернуть указатель на начало списка

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
	dummyHead := &ListNode{Val: -1, Next: head}

	cur, prevOfRemoval := dummyHead, dummyHead

	for cur.Next != nil {
		if n <= 0 {
			prevOfRemoval = prevOfRemoval.Next
		}
		cur = cur.Next
		n -= 1
		}

	removeNode := prevOfRemoval.Next
	prevOfRemoval.Next = removeNode.Next

	return dummyHead.Next
	}
```


---


## **LeetCode 21** [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)


Задача на слияние двух списков

Т.к. тут возможна вставка в начало (`head`) списка, используй `dummyHead` в решении

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{Val : -1}
    op := dummy

    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            op.Next = list1
            list1 = list1.Next
        } else {
            op.Next = list2
            list2 = list2.Next
        }
        op = op.Next
    }
    // Корнер кейс - если в одном из списков остались значения - 
    // добавляем их в результирующий список
    if list1 != nil {
        op.Next = list1
    }
    if list2 != nil {
        op.Next = list2
    }
    return dummy.Next
}
```


---


## **LeetCode 141** [Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)


Задача на выявление замкнутого цикла в списке

Алгоритм работает на приципе быстрого/медленного указателя: если есть цикл, то рано или поздно оба указателя встретяться в одной ноде

```go
func hasCycle(head *ListNode) bool {  
    slow := head  
    fast := head  
  
    for fast != nil && fast.Next != nil {  
       slow = slow.Next  
       fast = fast.Next.Next  
  
       if slow == fast {  
          return true  
       }  
    }    
    return false  
}
```



Вариант с хеш-талицей

Алгоритм работает так же, как и в **LeetCode 217** [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/) : 

1.  Прошедшая нода соответствует ключу в мапе: в ее значение мы кладем пустую структуру или `bool`

2. Когда нода встречается еще раз, мы проверяем на пустое значение

3. Если значение есть - это повтор, возвращаем `true`

```go
func hasCycle(head *ListNode) bool {
    visited_nodes := make(map[*ListNode]bool)
    current_node := head
    for current_node != nil {
        if visited_nodes[current_node] {
            return true
        }
        visited_nodes[current_node] = true
        current_node = current_node.Next
    }
    return false
}
```


---


## **LeetCode 142** [Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/)


Задача повторяет **LeetCode 141**, только нужно вернуть ноду, где начинается замкнутый цикл

```go
func cycleStart(head *ListNode) *ListNode {  
    slow := head  
    fast := head  
  
    for fast != nil && fast.Next != nil {  
       slow = slow.Next  
       fast = fast.Next.Next  
  
       if slow == fast {  
          break  
       }  
    }  
    // Проверяем, что есть цикл внутри списка
    if fast == nil || fast.Next == nil {  
       return nil  
    }  
	// Ключевая часть, она выявляет начало зацикливания
    slow2 := head  
    for slow != slow2 {  
       slow = slow.Next  
       slow2 = slow2.Next  
    }  
    return slow  
}
```


---


## LeetCode 148 [Sort List](https://leetcode.com/problems/sort-list/)


Задача на сортировку листа **по возрастанию**

Решением будет реализация соритровки слиянием - быстрый и простой алгоритм со сложностью **log n** 

Для поиска середины списка используй решение из **LeetCode 876** [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)(**Обязательно оборви связь между средней нодой и предыдущей**)


```go
func sortList(head *ListNode) *ListNode {  
    if head == nil || head.Next == nil {  
       return head  
    }  
  
    mid := getMid(head)  
    left := sortList(head)  
    right := sortList(mid)  
  
    return merge(left, right)  
}  
  
func getMid(head *ListNode) *ListNode {  
    slow, fast := head, head  
    // Добавляем еще указатель специально для разрыва
    var prev *ListNode  
  
    for fast != nil && fast.Next != nil {  
       prev = slow  
       slow = slow.Next  
       fast = fast.Next.Next  
    }  
    // Здесь мы обрываем связь обязательно
    prev.Next = nil  
  
    return slow  
}  
// Здесь мы параллельно проходимся по двум спискам и сравниваем их эл-ты
// После этого добавляем в чистый новый
func merge(left, right *ListNode) *ListNode {  
    dummy := &ListNode{Val: -1}  
    merged := dummy  
  
    for left != nil && right != nil{  
       if left.Val < right.Val{  
          merged.Next = left  
          left = left.Next  
       } else {  
          merged.Next = right  
          right = right.Next  
       }  
       merged = merged.Next  
    }  
    // Если есть остатки в одном из списков - добавляем все ноды в 
    // результирующий список
    if left != nil{  
       merged.Next = left  
    }  
    if right != nil{  
       merged.Next = right  
    }  
    return dummy.Next  
}
```


---


## **LeetCode 206** [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)


Задача на разворот списка, возвращается сам список


> [!attention] 
> Этот алгоритм решает множество других задач, поэтому его важно запомнить
> 
> [Объяснение алгоритма](https://leetcode.com/problems/reverse-linked-list/solutions/5612752/step-by-step-explained-with-images-easiest-to-understand-java-c-python-javascript-go-codes/)
 


```go
func reverseList(head *ListNode) *ListNode {  
  
    var prev, next *ListNode    
    curr := head
      
    for curr != nil {       
	    next = curr.Next       
	    curr.Next = prev       
	    prev = curr       
	    curr = next    
	}    
	return prev
}
```



Решение через рекурсию

```go
func reverseList(head *ListNode) *ListNode {  
    return helper(head, nil)  
}  
  
func helper(current *ListNode, prev *ListNode) *ListNode {  
    if current == nil{  
       return prev  
    }  
    next := current.Next  
    current.Next = prev  
    return helper(next, current)  
}
```


---


## **LeetCode 234** [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)


Задача на палиндром для односвязного списка (аналог для массивов - [Valid Palindrome - LeetCode](https://leetcode.com/problems/valid-palindrome/description/))

Порядок решения:

1. Мы находим середину с пом. быстрого/медленного указателя, причем нам не важно, чтобы быстрый дошел до конца списка

2. Разворачиваем вторую половину листа

3. Проходимся параллельно по двум половинам и сравниваем поэлементно

```go
func isPalindrome(head *ListNode) bool {  
    if head.Next == nil {  
       return true  
    }  
  
    slow, fast := head, head  
  
    for fast.Next != nil && fast.Next.Next != nil {  
       slow = slow.Next  
       fast = fast.Next.Next  
    }  
  
    slow.Next = reverseList(slow.Next)  
  
    slow = slow.Next  
  
    for slow != nil {  
       if slow.Val != head.Val {  
          return false  
       }  
       slow = slow.Next  
       head = head.Next  
    }  
    return true  
}  
  
func reverseList(head *ListNode) *ListNode {  
  
    var prev, next *ListNode  
    curr := head  
  
    for curr != nil {  
       next = curr.Next  
       curr.Next = prev  
       prev = curr  
       curr = next  
    }  
    return prev  
}
```


---


## **LeetCode 876** [Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/)


Задача на поиск середины листа

Если лист четный (2 ноды в середине), то возвращается правая нода

```go
func middleNode(head *ListNode) *ListNode {  
    if head == nil {  
       return head  
    }  
  
    slow, fast := head, head  
  
    for fast != nil && fast.Next != nil {  
       slow = slow.Next  
       fast = fast.Next.Next  
    }  
    return slow  
}
```



---


## Related


