Tags: [[для собеседований]]

#golang 



# Бинарный поиск
---

&emsp;&emsp;


> [!important] 
> До передачи в ф-ию массив **должен быть остортирован** 

&emsp;&emsp;

```go
func binarySearch(arr []int, target int) int {  
    L, R := 0, len(arr)-1  
    var mid int  
  
    for L <= R {  
       mid = (L + R) / 2  
       if target > arr[mid] {  
          L = mid + 1  
       } else if target < arr[mid] {  
          R = mid - 1  
       } else {  
          return mid  
       }  
    }    
    return -1  
}
```


&emsp;


## Поиск по интервалу



Для примера взято число 10

```go
func binarySearch(low, high int) int {
	var mid int

	for low <= high {
		mid = (low + high) / 2

		switch {
		case isCorrect(mid) > 0:
			high = mid - 1
		case isCorrect(mid) < 0:
			low = mid + 1
		default:
			return mid
		}
	}
	return -1
}

func isCorrect(n int) int {
	switch {
	case n > 10:
		return 1
	case n < 10:
		return -1
	default:
		return 0
	}
}
```


&emsp;

---
## **LeetCode 33** [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)


Задача на поиск `target` в отсортированном на `k` элементов вправо массиве

&emsp;&emsp;


Алгоритм решения:

1. Ищем, какая часть (левая, правая) осортирована
2. В отсортированной части проверяем, есть ли `target` там
3. Если есть - ищем бинарным поиском в нем, иначе ищем в другом

```go
func search(nums []int, target int) int {  
    low, high := 0, len(nums) - 1  
  
    for low <= high {  
       mid := (low + high) / 2  
  
       if nums[mid] == target {  
          return mid  
       }  

		// Ищем, какая часть отсортирована
       if nums[low] <= nums[mid] {  
       // проверяем, есть ли target в ней
          if nums[low] <= target && target < nums[mid] {  
             high = mid - 1  
        // если нет, ищем в другой части
          } else {  
             low = mid + 1  
          }  
       } else {  
          if nums[mid] < target && target <= nums[high] {  
             low = mid + 1  
          } else {  
             high = mid - 1  
          }  
       }    
    }  
    return -1  
}
```


&emsp;

---
## **LeetCode 33** [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)


Задача на поиск крайних левого и правого элементов, равные `target`

&emsp;&emsp;


Здесь для разнообразия используем `sort.Search`, который возвращает индекс `i` такой, что ф-ия `f(i)` возвращает `true`

`sort.Search` под капотом исопльзует бинарный поиск

Мы поочередно ищем левую, затем правую границу

```go
func searchRange(nums []int, target int) []int {  
    start := sort.Search(len(nums), func(i int) bool {  
       return nums[i] >= target  
    })  
    if start == len(nums) || nums[start] != target {  
       return []int{-1, -1}  
    }    
    
    end := sort.Search(len(nums) - start, func(i int) bool {  
       return nums[start + i] > target  
    }) + start - 1  
    
    return []int{start, end}  
}
```


