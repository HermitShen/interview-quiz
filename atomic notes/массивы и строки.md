Tags: [[для собеседований]]

#golang 



# 2 указателя


&emsp;


## **LeetCode 1** [Two Sum](https://leetcode.com/problems/two-sum/)


Задача на поиск двух чисел в массиве, чья сумма равна `target`

&emsp;


```go
func twoSum(nums []int, target int) []int {  
    L, R := 0, len(nums)-1  
    for L < R {  
       if nums[L]+nums[R] > target {  
          R--  
       } else if nums[L]+nums[R] < target {  
          L++  
       } else {  
          return []int{L, R}  
       }    
    }    
    return []int{-1, -1}  
}
```

&emsp;


Решение через хэш - таблицу

```go
func twoSum(nums []int, target int) []int {  
    found := make(map[int]int)  
  
    for i, num := range nums {  
       diff := target - num  
  
       if idx, ok := found[diff]; ok {  
          return []int{i, idx}  
       }       found[num] = i  
    }  
    return nil  
}
```


&emsp;


## **LeetCode 2** [ Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)


Задача на сложение непустых списков (**представь, что это 2 положительных числа**)

&emsp;&emsp;


![[Pasted image 20250805080604.png]]

Решение оч простое - ты проходишься по двум спискам до конца, сохраняя цифры значений нод с одниаковым индексом

Если нода вылезает за список, ее значение считается как 0

Если сумма >10, сохраняешь кол-во десятков (`carry`) и добавляешь к след. сумме, а остаток (`sum % 10`) записываешь в соотв. ноду в результирующем списке

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {  
    dummy := &ListNode{}  
    temp := dummy  
    carry := 0  
  
    for l1 != nil || l2 != nil || carry != 0 {  
       val1 := 0  
       if l1 != nil {  
          val1 = l1.Val  
          l1 = l1.Next  
       }  
  
       val2 := 0  
       if l2 != nil {  
          val2 = l2.Val  
          l2 = l2.Next  
       }  
  
       sum := val1 + val2 + carry  
       carry = sum / 10  
       temp.Next = &ListNode{Val: sum % 10}  
       temp = temp.Next  
    }  
  
    return dummy.Next  
}
```


&emsp;&emsp;


## **LeetCode 15** [3Sum](https://leetcode.com/problems/3sum/)


Задача на поиск всех триплетов в массиве, сумма элементов которых равна `0`

&emsp;&emsp;


Триплеты **не должны повторяться**

&emsp;&emsp;


В алгоритме используются 3 указателя:

- Указатель `i` проходит весь массив

- Указатели `j`, `k` идут с концов друг на друга до пересечения

Для реализации метода массив отсортирован, чтобы мы могли регулировать сумму с пом. указателей `j`, `k`

```go
func threeSum(nums []int) [][]int {  
    sort.Ints(nums)  
    result := [][]int{}  
  
    for i := 0; i < len(nums); i++ {  
	    // Проверка на начало массива и дубликаты
       if i > 0 && nums[i] == nums[i-1] {  
          continue  
       }  
       j, k := i+1, len(nums)-1  
       for j < k {  
          sum := nums[i] + nums[j] + nums[k]  
          if sum == 0 {  
             triplet := []int{nums[i], nums[j], nums[k]}  
             result = append(result, triplet)  
             j++  
             k--  
             // Не учитываем дубликаты
             for j < k && nums[j] == nums[j-1] {  
                j++  
             }  
             for j < k && nums[k] == nums[k+1] {  
                k--  
             }  
             // Подкручиваем чтобы получилась нужная сумма
          } else if sum < 0 {  
             j++  
          } else {  
             k--  
          }  
       }    }  
    return result  
}  
  
func main() {  
    nums := []int{-3, -1, -1, 1, 2, 2}  
    fmt.Println(threeSum(nums))  
}
// [[-3 1 2] [-1 -1 2]]
```


&emsp;&emsp;


## **LeetCode 26** [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)


Задача на подсчет уникальных чисел в отсортированном по возрастанию массиве

&emsp;&emsp;


Программа должна удалить дубликаты **на ходу**, для этого идеально подходят два указателя

```go
func removeDuplicates(nums []int) int {  
    index := 1  
    for i := 1; i < len(nums); i++ {  
       if nums[i] != nums[i-1] {  
          nums[index] = nums[i]  
          index++  
       }  
    }    
    return index  
}  
  
func main() {  
    someSlice := []int{1, 1, 2, 3, 3}  
    fmt.Println(removeDuplicates(someSlice))  
}
// 3
```


&emsp;&emsp;


## **LeetCode 88** [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)


Задача на слияние двух массивов в первый без выделения вспомогательного массива

&emsp;&emsp;


```go
func merge(nums1 []int, m int, nums2 []int, n int) {  
	// Указатель на последний элемент nums1
    p1 := m - 1  
    // Указатель на последний элемент nums2
    p2 := n - 1  
    // Указатель на последний элемент nums1+nums2
    p := m + n - 1  
  
    for p2 >= 0 && p1 >= 0 {  
       if nums1[p1] > nums2[p2] {  
          nums1[p] = nums2[p1]  
          p1--  
       } else {  
          nums1[p] = nums1[p2]  
          p2--  
       }  
       p--  
    }  
    // Проверка на корнер кейс, когда мелкий массив прошли быстрее 
	// большего. Остаток перекидываем в слитый массив
    for p2 >= 0 {  
       nums1[p] = nums2[p2]  
       p2--  
       p--  
    }  
}
```


&emsp;&emsp;


## **LeetCode 125** [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)


Задача на поиск палиндрома

&emsp;&emsp;


```go
func isPalindrom(s string) bool {  
    normalized := strings.ToLower(s)  
  
    left := 0  
    right := len(normalized) - 1  
  
    for left < right {  
       if !isAlphanumerical(normalized[left]) {  
          left++  
          continue  
       }  
  
       if !isAlphanumerical(normalized[left]) {  
          right--  
          continue  
       }  
  
       if normalized[left] != normalized[right] {  
          return false  
       }  
  
       left++  
       right--  
    }  
    return true  
}

// Проверяет на принадлежность к латинице или цифре
func isAlphanumerical(c byte) bool {  
    return (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')  
}
```


&emsp;&emsp;


## **LeetCode 189** [Rotate Array](https://leetcode.com/problems/rotate-array/)


Задача на разворот массива на `k` элементов вправо

&emsp;&emsp;


```go
func rotate(nums []int, k int) {  
  
    if k == 0 {  
       return  
    }  
  
    n := len(nums)  
    // вращение на `k` и на `k % n` — одно и то же
    k %= n  
    reverse(nums, 0, n-1)  
    reverse(nums, 0, k-1)  
    reverse(nums, k, n-1)  
}  
  
func main() {  
    nums := []int{1, 2, 3, 4, 5, 6, 7}  
    k := 3  
    rotate(nums, k)  
    fmt.Println(nums)  
}  
  
func reverse(nums []int, start int, end int) {  
    for start < end {  
       nums[start], nums[end] = nums[end], nums[start]  
       start++  
       end--  
    }  
}
// [5 6 7 1 2 3 4]
```

&emsp;&emsp;


Упрощенное решение без двух указателей сразу с учетом нового положения элементов

Здесь выделяется новый слайс после шифта и копируется в оригинальный

```go
func rotate(nums []int, k int) {
	n := len(nums)
	k = k % n
	res := make([]int, n)
	for i := 0; i < n; i++ {
		res[(i+k)%n] = nums[i]
	}
	copy(nums, res)
}
```


&emsp;&emsp;


## **LeetCode 283** [Move Zeroes](https://leetcode.com/problems/move-zeroes/)


Задача на сортировку нулей в массиве: все они должны съехать в конец массива, при этом порядок ненулевых элементов должен сохраниться

&emsp;&emsp;


```go
func moveZeroes(nums []int) []int {  
    zeroesClusterStart := 0  
  
    for i := range nums {  
       if nums[i] != 0 {  
          nums[zeroesClusterStart] = nums[i]  
          zeroesClusterStart++  
       }  
    }    
    for l := zeroesClusterStart; l < len(nums); l++ {  
       nums[l] = 0  
    }  
    return nums  
}  
  
func main() {  
    nums := []int{0, 1, 0, 3, 12}  
    fmt.Println(moveZeroes(nums))  
}
// [1 3 12 0 0]
```


&emsp;&emsp;


#  Хэш - таблица


&emsp;&emsp;


## **LeetCode 136** [Single Number](https://leetcode.com/problems/single-number/)


Задача на поиск числа без дубликатов, все остальные содержат **один** дубликат

&emsp;&emsp;


```go
func singleNumber(nums []int) int {  
    lastSeen := make(map[int]bool)  
    for _, num := range nums {  
       if _, hasNum := lastSeen[num]; hasNum {  
          delete(lastSeen, num)  
       } else {  
          lastSeen[num] = true  
       }  
    }    for k, _ := range lastSeen {  
       return k  
    }  
    return -1  
}
```



&emsp;&emsp;


## **LeetCode 205** [Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/)


Задача на проверку, являются ли 2 строки **изоморфными**

&emsp;&emsp;


> [!faq] 
> Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. 


&emsp;&emsp;


Алгоритм простой: мы проходим одновременно по двум строкам и связываем символ из одной строки с другим

Это делается с помощью мап, по одной на строку: каждая из них будет хранить числовое представление символа, с которым связан символ другой строки

Так мы сможем связывать пары символов, чтобы проверять на линковку в случае, если они уже есть в мапах

```go
func isIsomorphic(s string, t string) bool {  
	// 128 - всего литералов из ASCII
    map1 := make([]int, 128) // Stores frequency of s  
    map2 := make([]int, 128) // Stores frequency of t  
  
    for i := 0; i < len(s); i++ {  
       sCh := s[i]  
       tCh := t[i]  

		// Если оба символа ещё не были отображены — запоминаем 
		// соответствие
       if map1[sCh] == 0 && map2[tCh] == 0 {  
          map1[sCh] = int(tCh)  
          map2[tCh] = int(sCh)  
	    // Если хотя бы один из символов уже был сопоставлен, то
	    // проверяем, что сопоставление согласовано
       } else if map1[sCh] != int(tCh) || map2[tCh] != int(sCh) {  
          return false  
       }  
    }    
    return true  
}
```


&emsp;&emsp;


## **LeetCode 217** [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)


Задача на поиск как минимум двух дубликатов в массиве

&emsp;&emsp;


```go
func containsDuplicate(nums []int) bool {  
    set := make(map[int]any)  
    for _, num := range nums {  
       if _, hasNum := set[num]; hasNum {  
          return true  
       }  
       set[num] = struct{}{}  
    }    
    return false  
}  
  
func main() {  
    nums := []int{1, 1, 1, 3, 3, 4, 3, 2, 4, 2}  
    fmt.Println(containsDuplicate(nums))  
}
// true
```


&emsp;&emsp;


## **LeetCode 242** [Valid Anagram](https://leetcode.com/problems/valid-anagram/)


Задача на проверку строки на аннаграмму другой строки

&emsp;&emsp;


```go
func isAnagram(s string, t string) bool {  
	if len(s) != len(t) {
		return false
	}

    chars := make([]int, 26)  
  
    for _, v := range s {  
       i := int(v - 'a')  
       chars[i]++  
    }  
  
    for _, v := range t {  
       i := int(v - 'a')  
       chars[i]--  
    }  
  
    for _, v := range chars {  
       if v != 0 {  
          return false  
       }  
    }    
    return true  
}  
  
func main() {  
    s1 := "nagaram"  
    s2 := "anagram"  
    fmt.Println(isAnagram(s1, s2))  
}
// true
```

&emsp;&emsp;


Решение через хеш-таблицу

```go
func isAnagram(s string, t string) bool {  
    chars := make(map[int]int)  
  
    if len(s) != len(t) {  
       return false  
    }  
  
    for i := 0; i < len(s); i++ {  
       chars[int(s[i]-'a')]++  
       chars[int(t[i]-'a')]--  
    }  
  
    for _, v := range chars {  
       if v != 0 {  
          return false  
       }  
    }    return true  
}  
  
func main() {  
    s1 := "nagaram"  
    s2 := "anagram"  
    fmt.Println(isAnagram(s1, s2))  
}
// true
```


&emsp;&emsp;


## **LeetCode 290** [Word Pattern](https://leetcode.com/problems/word-pattern/)


Задача частично повторяет [205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/), но вместо двух слов у нас паттерн и строка

&emsp;&emsp;


Здесь мы мапаем не буквы, а букву и строку, в остальном все то же самое

```go
func wordPattern(pattern string, s string) bool {  
    splitS := strings.Split(s, " ")  
    if len(pattern) != len(splitS) {  
       return false  
    }  
  
    patternMap := map[byte]string{}  
    sMap := map[string]byte{}  
  
    for idx := 0; idx < len(pattern); idx++ {  
       sChar := splitS[idx]  
       pChar := pattern[idx] // rune  
  
       if pv, ok := patternMap[pChar]; ok && pv != splitS[idx] {  
          return false  
       } else {  
          patternMap[pChar] = splitS[idx]  
       }  
       if sv, ok := sMap[sChar]; ok && sv != pattern[idx] {  
          return false  
       } else {  
          sMap[sChar] = pattern[idx]  
       }    }  
    return true  
}
```


&emsp;&emsp;


## **LeetCode 347** [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)


Задача на поиск самого повторяющегося элемента в массиве

&emsp;&emsp;


Мы выводим топ `k` этих элементов в виде слайса

```go
package main  
  
import "fmt"  
  
func topFrequent(nums []int, k int) []int {  
    // создаем мапу с кол-ом повторений для каждого числа в nums  
    frequencies := make(map[int]int)  
    for _, num := range nums {  
       frequencies[num]++  
    }  
    // создаем слайс, где индекс - кол-во повторений, а значение - это 
    // слайс чисел  
    // len(nums)+1 на случай, если массив состоит из одного числа  
    // buckets := make([][]int, len(nums)+1)  
    for num, frequency := range frequencies {  
       buckets[frequency] = append(buckets[frequency], num)  
    }  
    result := make([]int, 0, k)  
    for i := len(buckets) - 1; i >= 0 && len(result) < k; i-- {  
       for _, num := range buckets[i] {  
          result = append(result, num)  
          if len(result) == k {  
             return result  
          }  
       }    
    }    
    // Возвращаем result, если дошли до конца (например, если уникальных 
    // чисел меньше k)  
    return result  
}  
  
func main() {  
    nums := []int{1, 1, 1, 3, 3, 2}  
    fmt.Println(topFrequent(nums, 2))  
}
// [1 3]
```


&emsp;&emsp;


## **LeetCode 350** [Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/)


Задача на поиск пересечения двух массивов

&emsp;&emsp;


Каждый элемент в результ. массиве появляется столько раз, сколько в обоих массивах

Порядок элементов не важен

```go
func intersect(nums1 []int, nums2 []int) []int {  
    frequencies := make(map[int]int, 1001)  
    for _, num := range nums1 {  
       frequencies[num]++  
    }  
    result := make([]int, 0, len(frequencies))  
    for _, num := range nums2 {  
       if count, ok := frequencies[num]; ok && count > 0 {  
          result = append(result, num)  
          frequencies[num]--  
       }  
    }    
    return result  
}  
  
func main() {  
    nums1 := []int{4, 9, 5}  
    nums2 := []int{9, 4, 9, 8, 4}  
    fmt.Println(intersect(nums1, nums2))  
}
// [9 4]
```

