Tags: [[для собеседований]]

#golang 


## Связанный список


Реализация односвязаного списка

```go
type ListNode struct {  
    Val  int  
    Next *ListNode  
}  
  
func NewListNode(val int) *ListNode {  
    return &ListNode{  
       Val:  val,  
       Next: nil,  
    }
}  
  
type SinglyLinkedList struct {  
    Head, Tail *ListNode  
}  
  
func NewSinglyLinkedList() *SinglyLinkedList {  
    node := NewListNode(-1)  
    return &SinglyLinkedList{  
       Head: node,  
       Tail: node,  
    }
}  
  
func (s *SinglyLinkedList) InsertEnd(val int) {  
    s.Tail.Next = NewListNode(val)  
    s.Tail = s.Tail.Next  
}  
  
func (s *SinglyLinkedList) Remove(index int) {  
    if index < 0 {
		return
	}
    
    prev := s.Head  
    for i := 0; i < index && prev.Next != nil; i++ {
		prev = prev.Next
	}
  
    if prev.Next != nil {  
       if prev.Next == s.Tail {  
          s.Tail = prev  
       }  
       prev.Next = prev.Next.Next  
    }  
}  
  
func (s *SinglyLinkedList) Print() {  
    curr := s.Head.Next  
    for curr != nil {  
       fmt.Printf("%d -> ", curr.Val)  
       curr = curr.Next  
    }  
  
    fmt.Println()  
}
```


Если список закольцовывается, это можно учесть с пом. кода ниже

```go
entryPoint :=  list.Head  
// Старт цикла
pos := 3  
// Присваиваем начальную ноду цикла в entryPoint
for range pos {  
    entryPoint = entryPoint.Next  
}  
list.Tail.Next = entryPoint  
// Нужно чтобы никто не смог перезаписать tail, т.к. физического конца у списка теперь нет
list.Tail = nil
```




Реализация двусвязного списка

```go
// DoublyLinkedListNode is the node type for a doubly linked list
type DoublyLinkedListNode struct {  
    val  int  
    next *DoublyLinkedListNode  
    prev *DoublyLinkedListNode  
}  
  
// DoublyLinkedList is the structure for a doubly linked list  
type DoublyLinkedList struct {  
    head *DoublyLinkedListNode  
    tail *DoublyLinkedListNode  
}  
  
// NewDoublyLinkedListNode creates a new doubly linked list node  
func NewDoublyLinkedListNode(val int) *DoublyLinkedListNode {  
    return &DoublyLinkedListNode{  
       val:  val,  
       next: nil,  
       prev: nil,  
    }}  
  
// NewDoublyLinkedList creates a new doubly linked list  
func NewDoublyLinkedList() *DoublyLinkedList {  
    head := NewDoublyLinkedListNode(-1)  
    tail := NewDoublyLinkedListNode(-1)  
    head.next = tail  
    tail.prev = head  
    return &DoublyLinkedList{  
       head: head,  
       tail: tail,  
    }}  
  
// InsertFront inserts a new node at the front of the list  
func (d *DoublyLinkedList) InsertFront(val int) {  
    newNode := NewDoublyLinkedListNode(val)  
    newNode.prev = d.head  
    newNode.next = d.head.next  
  
    d.head.next.prev = newNode  
    d.head.next = newNode  
}  
  
// InsertEnd inserts a new node at the end of the list  
func (d *DoublyLinkedList) InsertEnd(val int) {  
    newNode := NewDoublyLinkedListNode(val)  
    newNode.next = d.tail  
    newNode.prev = d.tail.prev  
  
    d.tail.prev.next = newNode  
    d.tail.prev = newNode  
}  
  
// RemoveFront removes the node at the front of the list  
func (d *DoublyLinkedList) RemoveFront() {  
    if d.head.next != d.tail {  
       d.head.next.next.prev = d.head  
       d.head.next = d.head.next.next  
    }  
}  
  
// RemoveEnd removes the node at the end of the list  
func (d *DoublyLinkedList) RemoveEnd() {  
    if d.tail.prev != d.head {  
       d.tail.prev.prev.next = d.tail  
       d.tail.prev = d.tail.prev.prev  
    }  
}  
  
// Print prints the doubly linked list  
func (d *DoublyLinkedList) Print() {  
    curr := d.head.next  
    for curr != d.tail {  
       fmt.Printf("%d -> ", curr.val)  
       curr = curr.next  
    }  
    fmt.Println()  
}
```

<div class="chapter-spacer"></div>

## Стэк, очередь


Реализация стека с методами `Push(int)` и `Pop() int`

```go
package main  
  
import "fmt"  
  
type Stack struct {  
    items []int  
}  
  
func (s *Stack) Push(i int) {  
    s.items = append(s.items, i)  
}  
  
func (s *Stack) Pop() int {  

	if len(s.items) == 0 {
		fmt.Println("Error: Stack is empty")
		return 0
	}

    l := len(s.items) - 1  
    toRemove := s.items[l]  
    s.items = s.items[:l]  
    return toRemove  
}  
  
func main() {  
    myStack := Stack{}  
    fmt.Println(myStack)  
    myStack.Push(100)  
    myStack.Push(200)  
    myStack.Push(300)  
    fmt.Println(myStack)  
    myStack.Pop()  
    fmt.Println(myStack)  
}
// {[]}
// {[100 200 300]}
// {[100 200]}
```



Очередь почти так же реализуется, только удаляем и возвращаем не последний, а первый элемент

```go
type Queue struct {  
    items []int  
}  
  
func (q *Queue) Enqueue(i int) {  
    q.items = append(q.items, i)  
}  
  
func (q *Queue) Dequeue() int {  
    toRemove := q.items[0]  
    q.items = q.items[1:]  
    return toRemove  
}  
  
func main() {  
    myQueue := Queue{}  
    fmt.Println(myQueue)  
    myQueue.Enqueue(100)  
    myQueue.Enqueue(200)  
    myQueue.Enqueue(300)  
    fmt.Println(myQueue)  
    myQueue.Dequeue()  
    fmt.Println(myQueue)  
}
// {[]}
// {[100 200 300]}
// {[200 300]}
```

<div class="chapter-spacer"></div>

## Бинарное дерево (Binary Search Tree)


Реализация бинарного дерева с методами вставки (`Insert`) и удаления (`Remove`)

Для метода удаления есть вспом. ф-ия, которая ищет ноду с минимальным значением

```go
type TreeNode struct {  
    Val   int  
    Left  *TreeNode  
    Right *TreeNode  
}  
  
func NewTreeNode(val int) *TreeNode {  
    return &TreeNode{  
       Val: val,  
    }}  
  
type InsertAndRemove struct {  
}  
  
// Insert a new node and return the root of the BST.  
func (ir *InsertAndRemove) Insert(root *TreeNode, val int) *TreeNode {  
    if root == nil {  
       return NewTreeNode(val)  
    }  
    if val > root.Val {  
       root.Right = ir.Insert(root.Right, val)  
    } else if val < root.Val {  
       root.Left = ir.Insert(root.Left, val)  
    }    return root  
}  
  
// Return the minimum value node of the BST.  
func (ir *InsertAndRemove) MinValueNode(root *TreeNode) *TreeNode {  
    curr := root  
    for curr != nil && curr.Left != nil {  
       curr = curr.Left  
    }  
    return curr  
}  
  
// Remove a node and return the root of the BST.  
func (ir *InsertAndRemove) Remove(root *TreeNode, val int) *TreeNode {  
    if root == nil {  
       return nil  
    }  
    if val > root.Val {  
       root.Right = ir.Remove(root.Right, val)  
    } else if val < root.Val {  
       root.Left = ir.Remove(root.Left, val)  
    } else {  
       if root.Left == nil {  
          return root.Right  
       } else if root.Right == nil {  
          return root.Left  
       } else {  
          minNode := ir.MinValueNode(root.Right)  
          root.Val = minNode.Val  
          root.Right = ir.Remove(root.Right, minNode.Val)  
       }    }    return root  
}
```




В двоичном дереве поиска (**BST**, Binary Search Tree) — и вообще в любом дереве — **обходы** (traversals) определяют порядок, в котором ты посещаешь узлы. Самые известные — это:

- **Preorder traversal** — прямой (корень → левое → правое)
    
- **Postorder traversal** — обратный (левое → правое → корень)
	
- **Order traversal** - от меньшего к большему


```go
func (d *DFS) InOrder(root *TreeNode) {  
    if root == nil {  
       return  
    }  
    d.InOrder(root.Left)  
    fmt.Println(root.Val)  
    d.InOrder(root.Right)  
}  
  
// PreOrder traversal  
func (d *DFS) PreOrder(root *TreeNode) {  
    if root == nil {  
       return  
    }  
    fmt.Println(root.Val)  
    d.PreOrder(root.Left)  
    d.PreOrder(root.Right)  
}  
  
// PostOrder traversal  
func (d *DFS) PostOrder(root *TreeNode) {  
    if root == nil {  
       return  
    }  
    d.PostOrder(root.Left)  
    d.PostOrder(root.Right)  
    fmt.Println(root.Val)  
}
```

<div class="chapter-spacer"></div>

## Префиксное дерево



Реализация префиксного дерева, хранящее все символы латиницы из нижнего регистра

```go
// AlphabetSize is the number of possible characters in the trie  
const AlphabetSize = 26  
  
// Node represents each node in the trie  
type Node struct {  
    children [26]*Node  
    isEnd    bool  
}  
  
// Trie represents a trie and has a pointer to the root node  
type Trie struct {  
    root *Node  
}  
  
// InitTrie will create new Trie  
func InitTrie() *Trie {  
    result := &Trie{root: &Node{}}  
    return result  
}  
  
// Insert will take in a word and add it to the trie  
func (t *Trie) Insert(w string) {  
    wordLength := len(w)  
    currentNode := t.root  
    for i := 0; i < wordLength; i++ {  
       charIndex := w[i] - 'a' // Буквы алфавита получат индекс от 0 до 25, где 0 - первая буква  
       if currentNode.children[charIndex] == nil {  
          currentNode.children[charIndex] = &Node{}  
       }       currentNode = currentNode.children[charIndex]  
    }    currentNode.isEnd = true  
}  
  
// Search will take in a word and RETURN true if that word is included, otherwise false  
func (t *Trie) Search(w string) bool {  
    wordLength := len(w)  
    currentNode := t.root  
    for i := 0; i < wordLength; i++ {  
       charIndex := w[i] - 'a' // Буквы алфавита получат индекс от 0 до 25, где 0 - первая буква  
       if currentNode.children[charIndex] == nil {  
          return false  
       }  
       currentNode = currentNode.children[charIndex]  
    }    if currentNode.isEnd == true {  
       return true  
    }  
    return false  
}  
  
func main() {  
    myTrie := InitTrie()  
  
    toAdd := []string{  
       "aboba",  
       "amogus",  
       "biba",  
       "oregon",  
       "oregano",  
       "oreo",  
    }  
    for _, v := range toAdd {  
       myTrie.Insert(v)  
    }  
    fmt.Println(myTrie.root)  
    fmt.Println(myTrie.Search("aboba"))  
    fmt.Println(myTrie.Search("amogus"))  
    fmt.Println(myTrie.Search("bibi"))  
    fmt.Println(myTrie.Search("oreo"))  
}
// &{[0xc0000001c0 0xc000000a80 <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> 0xc000000e00 <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil> <nil>] false}
// true
// true
// false
// true
```

<div class="chapter-spacer"></div>

## Хэш - таблица


Реализация хеш-таблицы из 8 ячеек

Хеш ф-ия здесь суммирует числовые значения символов и берет остаток от деления на длину массива

```go
package main  
  
import "fmt"  
  
// ArraySize is the size of the hash table array  
const ArraySize = 8  
  
// HashTable will hold an array  
type HashTable struct {  
    array [ArraySize]*bucket  
}  
  
// bucket is a linked list in each slot of the array  
type bucket struct {  
    head *bucketNode  
}  
  
// bucketNode structure  
type bucketNode struct {  
    key  string  
    next *bucketNode  
}  
  
// Insert will take in a key and add it to the hash table array  
func (h *HashTable) Insert(key string) {  
    index := hash(key)  
    h.array[index].insert(key)  
}  
  
// Search will take in a key and return true if that key is stored in the hash table  
func (h *HashTable) Search(key string) bool {  
    index := hash(key)  
    return h.array[index].search(key)  
}  
  
// Delete will take in a key and delete it from the hash table  
func (h *HashTable) Delete(key string) {  
    index := hash(key)  
    h.array[index].delete(key)  
}  
  
// insert will take in a key and add it to the bucket  
func (b *bucket) insert(k string) {  
    if b.search(k) == false {  
       newNode := &bucketNode{key: k}  
       newNode.next = b.head  
       b.head = newNode  
    } else {  
       fmt.Println(k, "already exists")  
    }
}  
  
// search will take in a key and return true if the bucket has it  
func (b *bucket) search(k string) bool {  
    currentNode := b.head  
    for currentNode != nil {  
       if currentNode.key == k {  
          return true  
       }  
       currentNode = currentNode.next  
    }  
    return false  
}  
  
// delete will take in a key and delete the node from the bucket  
func (b *bucket) delete(k string) {  
  
    if b.head.key == k {  
       b.head = b.head.next  
       return  
    }  
  
    previousNode := b.head  
    for previousNode.next != nil {  
       if previousNode.next.key == k {  
          previousNode.next = previousNode.next.next  
       }  
    }
}  
  
// hash  
func hash(key string) int {  
    sum := 0  
    for _, v := range key {  
       sum += int(v)  
    }    
    return sum % ArraySize  
}  
  
// Init will create a bucket in each slot of the hash table  
func Init() *HashTable {  
    result := &HashTable{}  
    for i := range result.array {  
       result.array[i] = &bucket{}  
    }    
    return result  
}  
  
func main() {  
    hashTable := Init()  
    list := []string{  
       "ERIC",  
       "KENNY",  
       "BUTTERS",  
       "TOKEN",  
       "KYLE",  
       "STAN",  
    }  
    
    for _, v := range list {  
       hashTable.Insert(v)  
    }
}
```



