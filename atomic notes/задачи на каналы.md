Tags: [[для собеседований]]

#golang 



# Задачи
---



## Задача на множественное присвоение
---


![[Screenshot From 2025-10-15 03-29-35 1.png]]


Эта программа выпонится примерно за 2 секунды,  

Когда мы делаем несколько присвоений в одной строке, ф-ии выполняются **последовательно**


Мы не будем блокироваться, потому что оба канала будут закрыты


## Задача на `range` с буфер. каналом
---


![[Screenshot From 2025-10-15 22-00-01.png]]


Не имеет значение, есть ли у канал буфер или нет, когда мы читаем его через `range`

В обоих случаях нужно **закрывать его**, чтобы **не получить deadlock**

Также нужно учитывать, что мы можем читать значения из буфера, **даже если канал закрыт**


Исправить можно через обертку в виде горутины или так:

![[Screenshot From 2025-10-15 22-03-31.png]]


## Задача на контекст 
---


![[Screenshot From 2025-10-15 22-24-26.png]]

Тут нужно обернуть ф-ию `unpredictableFunc`, чтобы она работала не дольше конкретного времени


В подобных задачах обычно хотят увидеть **контекст** в параметрах и **ошибку** в возврате

Причем если ошибка непустая, рез-т ф-ии не должен печатать числовое значение



Вот одно из возможных решений:

```go
type CustomErr struct {  
	Error  error  
	Result int  
}  
  
func unpredictableFunc() int {  
	n := rand.IntN(40)  
	time.Sleep(time.Duration(n) * time.Second)  
	return n  
}  
  
func predictableFunc(ctx context.Context) CustomErr {  
	var cancel context.CancelFunc  
  
	if _, ok := ctx.Deadline(); !ok {  
	   ctx, cancel = context.WithTimeout(ctx, 5*time.Second)  
	   defer cancel()  
	}  
	ch := make(chan struct{})  
	var result int  
  
	go func() {  
	   result = unpredictableFunc()  
	   close(ch)  
	}()  
	select {  
	case <-ch:  
	case <-ctx.Done():  
	   return CustomErr{  
		  Error:  ctx.Err(),  
		  Result: 0,  
	   }    }  
	return CustomErr{  
	   Error:  nil,  
	   Result: result,  
	}
}  
  
func main() {  
	ctx := context.Background()  
  
	val := predictableFunc(ctx)  
	if errors.Is(val.Error, context.DeadlineExceeded) {  
	   fmt.Println("context cancelled")  
	   return  
	}  
  
	fmt.Println(val)  
}
```

Здесь мы обогатили код несколькими элементами:

- Кастомная структура `CustomErr` для хендлинга ошибок
  
- Проверка на тип контекста; если он без таймаута - оборачиваем в него
  
- Непредсказуемая ф-ия выносится в отдельную горутину, чтобы не тормозить программу
  
- Проврека через `select` на отмененный контекст и статус канала `ch` - если канал закрыт, значит ф-я `unpredictableFunc` выполнилась и можно вернуть ответ 


---


## Канал с каналами
---


![[Screenshot From 2025-10-15 23-31-14 1.png]]


Эта программа абсолютна **рабочая**, никаких ошибок компиляции не будет

Через type definition мы можем указать тип, который под собой будет представлять канал таких же типов


Кроме того мы можем записывать в `select` **несколько одинаковых кейсов**


Рез-т этой программы зависит от рандома


## Задача с собеса на 500к
---


Здесь лучше посмотреть [отдельный ролик](https://www.youtube.com/watch?v=wZCLVt_5-4c)

