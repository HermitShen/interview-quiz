Tags: [[для собеседований]]

#golang 



# GC

 
 

## Что такое сборщик мусора? Какие данные попадают под термин 'мусор'

 


GC нужен для того, чтобы освобождать память в **куче** (stack сам себя чистит) от объектов, которые больше не нужны приложению

Мусор - это объекты, на которые **никто** больше **не ссылается** (нет валидных ссылок)
 


Здесь в примере мы создали слайс на стеке. Сама структура у ссылочного типа (у слайса это массив) попадет в кучу, а ссылка останется на стеке

![[Screenshot From 2025-10-02 13-36-55.png|600]]

Если после отработки ф-ии мы не передали указатель на массив, он станет **мусорным объектом**, т.к. все указатели либо не используются дальше либо ячейки памяти с переменной указателя перетерлись

 

Тут ссылка все еще живет в памяти, но нигде не используется

![[Screenshot From 2025-10-02 13-39-59.png|600]]

 


А здесь указатель перетерся другой ф-ей

![[Screenshot From 2025-10-02 13-43-07.png|600]]

 
 

## Как работает GC (для ознакомительного вопроса)

 


GC работает по алгоритму `Concurrent mark & sweep`

Он трехцветный, т.е. у объектов может быть 3 цвета при разметке:

- белый
- серый
- черный

 


Работа алгоритма состоит из 2 фаз:

- Фаза разметки Aka `Sweep termination` (STW)

![[Screenshot From 2025-10-02 14-03-23.png|600]]

 


- Фаза очистки, которая возобновляет работу программы, GC не работает уже  
  
 ![[Screenshot From 2025-10-02 14-05-16.png|600]]
 
 

## Когда запускается GC?

 


GC запускается в нескольких случаях:

- Когда память в **куче** заполняется до о**пределенного значения** по **специальной формуле**, которая зависит от параметров `GOGC` и `MEMLIMIT`

- Планировщиком **раз в 2 минуты**
  
- Можно запустить вручную через библиотеку `runtime`
 


> [!important] 
> Важные факты о работе GC:
> 
> - GC работает **конкурентно** с приложением, т.е. он не прервет выполнение прграммы
> 
> - GC забирает **25%** ресурсов CPU себе (из 4 лог. ядер забирает 1 и т.д.)
> 
> - Работающие горутины могут быть привлечены на помощь к работе GC.
> 	
> 	По факту вместо аллокации памяти они будут заниматься **разметкой объектов**
> 	Причем очередь горутин будут зависеть от частоты аллокаций
> >
>
> - GC можно **отключить** через параметр `GOGC = off` (без `MEMLIMIT`!)

 
 

## Когда может потребоваться отключать GC?

 


В некоторых случаях:

- Когда приложение потребляет мало памяти (например CLI приложения)

- Мы хотим сами управлять GC

- Для тестов/профилирования

 
 

## Как работает GC (для вопроса в глубину)

 


Перед стартом GC наши объекты представляют собой такую схему

![[Screenshot From 2025-10-02 15-12-16.png|700]]

Рантайм GO **знает** о всех объектах в куче (он может по ним проитерироваться), но **не знает**, какие ему надо удалить

Поэтому перед удалением их надо разметить

 


Перед разметкой рантайм находит все ссылки на объекты в куче и кладет их в специальную очередь

![[Screenshot From 2025-10-02 15-16-36.png|700]]

 


Все объекты в куче, на которые есть ссылки, изначально помечаются **серым**

После этого рантайм рекурсивно ищет другие ссылки, которые найдет в начальной

Если такие существуют, то объект, на который указывала начальная ссылка, окрашивается **черным**, а подссылки окрашиваются **серым**

![[Screenshot From 2025-10-02 15-18-24.png|700]]

Черный цвет означает, что объект "живой", т.е. мы нашли на него ссылку среди стеков горутин или глобальных переменных

Все подссылки попадают **в конец очереди** 

 


После всего вышеперечисленного берется следующая ссылка из очереди и повторяются те же самые действия

![[Screenshot From 2025-10-02 15-29-39.png|700]]

 


**В конце разметки в куче остаются только черные и белые объекты**, причем ни один из черных не ссылается на белый

![[Screenshot From 2025-10-02 15-31-45.png|700]]

 


После разметки GC **выключается**, а оставшиеся белые объекты по мере работы программы **затираются аллокациями новых объектов на куче**

![[Screenshot From 2025-10-02 15-35-22.png|700]]

 
