Tags: [[для собеседований]]

#golang 



## GC



1. Что такое сборщик мусора? Какие данные попадают под термин 'мусор'

	GC нужен для того, чтобы освобождать память в **куче** (stack сам себя чистит) от объектов, которые больше не нужны приложению
	
	Мусор - это объекты, на которые **никто** больше **не ссылается** (нет валидных ссылок)
	
	
	
	Здесь в примере мы создали слайс на стеке. Сама структура у ссылочного типа (у слайса это массив) попадет в кучу, а ссылка останется на стеке
	
	![[Screenshot From 2025-10-02 13-36-55.png]]
	
	Если после отработки ф-ии мы не передали указатель на массив, он станет **мусорным объектом**, т.к. все указатели либо не используются дальше, либо ячейки памяти с переменной указателя перетерлись
	
	
	Тут ссылка все еще живет в памяти, но нигде не используется
	![[Screenshot From 2025-10-02 13-39-59.png]]
	
	
	А здесь указатель перетерся другой ф-ей
	![[Screenshot From 2025-10-02 13-43-07.png]]


---


2. Как работает GC (для ознакомительного вопроса)

	GC работает по алгоритму `Concurrent mark & sweep`
	
	Он трехцветный, т.е. у объектов может быть 3 цвета при разметке:
	
	- белый
	- серый
	- черный
	
	
	Работа алгоритма состоит из 2 фаз:
	
	- Фаза разметки Aka `Sweep termination` (STW)
	  
	![[Screenshot From 2025-10-02 14-03-23.png]]
	
	
	- Фаза очистки, которая возобновляет работу программы, GC не работает уже  
	 ![[Screenshot From 2025-10-02 14-05-16.png]]


---


3. Когда запускается GC?

	GC запускается в нескольких случаях:
	
	- Когда память в **куче** заполняется до о**пределенного значения** по **специальной формуле**, которая зависит от параметров `GOGC` и `MEMLIMIT`
	
	- Планировщиком **раз в 2 минуты**
	  
	- Можно запустить вручную через библиотеку `runtime`


> [!important] 
> Важные факты о работе GC:
> 
> - GC работает **конкурентно** с приложением, т.е. он не прервет выполнение прграммы
> 
> - GC забирает **25%** ресурсов CPU себе (из 4 лог. ядер забирает 1 и т.д.)
> 
> - Работающие горутины могут быть привлечены на помощь к работе GC.
> 	
> 	По факту вместо аллокации памяти они будут заниматься **разметкой объектов**
> 	Причем очередь горутин будут зависеть от частоты аллокаций
> >
>>
> - GC можно **отключить** через параметр `GOGC = off` (без `MEMLIMIT`!)


---


4. Когда может потребоваться отключать GC?

	В некоторых случаях:
	
	- Когда приложение потребляет мало памяти (например CLI приложения)
	
	- Мы хотим сами управлять GC
	  
	- Для тестов/профилирования


---


5. Как работает GC (для вопроса в глубину)

	Перед стартом GC наши объекты представляют собой такую схему
	
	![[Screenshot From 2025-10-02 15-12-16.png]]
	
	Рантайм GO **знает** о всех объектах в куче (он может по ним проитерироваться), но **не знает**, какие ему надо удалить
	
	Поэтому перед удалением их надо разметить
	
	
	
	Перед разметкой рантайм находит все ссылки на объекты в куче и кладет их в специальную очередь
	
	![[Screenshot From 2025-10-02 15-16-36.png]]
	
	
	
	Все объекты в куче, на которые есть ссылки, изначально помечаются **серым**
	
	После этого рантайм рекурсивно ищет другие ссылки, которые найдет в начальной
	
	Если такие существуют, то объект, на который указывала начальная ссылка, окрашивается **черным**, а подссылки окрашиваются **серым**
	
	![[Screenshot From 2025-10-02 15-18-24.png]]
	
	Черный цвет означает, что объект "живой", т.е. мы нашли на него ссылку среди стеков горутин или глобальных переменных
	
	Все подссылки попадают **в конец очереди** 
	
	
	
	После всего вышеперечисленного берется следующая ссылка из очереди и повторяются те же самые действия
	
	![[Screenshot From 2025-10-02 15-29-39.png]]
	
	
	
	**В конце разметки в куче остаются только черные и белые объекты**, причем ни один из черных не ссылается на белый
	
	![[Screenshot From 2025-10-02 15-31-45.png]]
	
	
	
	После разметки GC **выключается**, а оставшиеся белые объекты по мере работы программы **затираются аллокациями новых объектов на куче**
	
	![[Screenshot From 2025-10-02 15-35-22.png]]
	
	
	
	
	Однако параллельно GC у нас работает и сама программа, которая во время разбметки объектов может аллоцировать новые объекты в куче
	
	Если не поставить какое-то ограничение, GC может сразу пометить новые объекты как неживые, хотя на них будут ссылки в стеке/глобальных переменных 
	
	Именно для этого во время подготовки к разметке ставиться **барьер на запись**
	
	Для этой операции как раз мы и **останавливаем на время горутины перед фазой разметки** (STW - `stop the world`)
	
	
	
	Барьер на запись - это просто **глобальная переменная**, у которой при каждой аллокации проверяется значение флага - установлен он или нет
	
	Если **установлен**, то каждый новый объект будет **окрашиваться сразу в черный**, а не белый 
	
	![[Screenshot From 2025-10-02 20-46-22.png]]
	
	![[Screenshot From 2025-10-02 20-46-49.png]]


> [!tip] 
> Использование трех цветов вместо двух на этапе разметки выбрано специально
> 
> Раскраска вершин графа в три цвета - **типичный способ поиска циклов в графе** 


---


6. Можно ли заменить кучу, чтобы не использовать GC?

	Т.к. мы хотим реже использовать GC  и стараться аллоцировать все на стеке, нам может потребоваться заменить кучу другой структурой
	
	Для этого есть **пулл** (`memory pool`) - буфер для данных одного типа
	
	Их можно реализовать двумя способами:
	
	- Написать вручную, например через каналы с буфером
	
	-  `sync.Pool` с аллокациями в куче
	  
	- `sync.Pool` с аллокациями в арене


---


7. Как настроить GC

	Настроить GC можно через параметры `GOGC` и `MEMLIMIT`
	
	`GOGC` влияет на частоту запуска GC - чем **больше** значение, тем **реже** запускается GC, однако тем **больше памяти** будет расходовать приложение
	
	
	
	Память, при которой запускается GC, расчитывается по определенной формуле, частью которой является `GOGC`:
	
	![[Screenshot From 2025-10-02 22-12-04.png]]
	Здесь живые объекты - это объекты в куче, окрашенные в черный
	Корневые объекты - это объекты в стеке и глоб. переменных
	
	Именно **при достижении этого лимита** все размеченные объекты будут **удалены** сборщиком мусора
	
	
	
	По умолчанию значение `GOGC` равно 100
	
	Т.е. если размеры объектов суммарно будут `8Mb` и `2Mb` соответственно, лимит будет таким
	
	![[Screenshot From 2025-10-02 22-19-36.png]]
	
	
	Из этой формулы можно сделать вывод о работе с `GOGC`:
	
	![[Screenshot From 2025-10-02 22-23-20.png]]
	
	
	
	
	C `MEMLIMIT` все просто - если память в куче достигнет значения этого параметра, - запустится GC
	
	![[Screenshot From 2025-10-02 22-25-45.png]]


---


## Related



> [!tip]  
> Посмотреть на работу GC с различными настройками можно так:
> 
>  ```go
>  type data struct {  
>     a []byte  
> }  
>   
> //go:noinline  
> func getData() *data {  
>     arr := [300]byte{}  
>   
>     return &data{a: arr[:100]}  
> }  
>   
> func main() {  
>   
>     t1 := time.NewTicker(100 * time.Microsecond)  
>     go func() {  
>        for range t1.C {  
>           getData()  
>        }    }()  
>     t := time.NewTicker(1 * time.Second)  
>   
>     var m runtime.MemStats  
>     now := time.Now()  
>     for curr := range t.C {  
>        runtime.ReadMemStats(&m)  
>   
>        fmt.Printf(  
>           "GC_enabled=%v     GC_runs=%v     live_now=%v  pause_total_ms=%.2f  time=%5.0f sec\n",  
>           m.EnableGC, m.NumGC, m.Mallocs-m.Frees, float64(m.PauseTotalNs)/1e6, curr.Sub(now).Seconds())  
>     }}
>  ```
>  
> `go:noinline` обязателен, чтобы компилятор не убил неиспользованную переменную `&data{a: arr[:100]}`
