Tags: [[для собеседований]]

#golang 



## Стек, куча



## Можно ли точно сказать, в каком месте будет создана переменная: **стек или куча?**

Нет, нельзя, все зависит от компилятора и escape-анализатора

Алгоритм эскейпа может меняться от версии к версии


Однако есть нкоторые правила, которые работают почти всегда

![[Screenshot From 2025-10-01 17-32-53.png]]

> [!note] 
> Для последних версий go **1.24+** достаточно даже 1mb

> [!info] 
> Под структурами данных здесь имеются ввиду бакеты (для `map`), массивы (для `slice`), массив битов (для `string`), кольцевой буфер (для `chan`)

> [!tldr] 
> По возможности аллокатор в GO старается разместить переменные на сначала на стеке
> 
> Но уже если анализатор не доказал, что такое размещение нужно, она отправляется в кучу 
> 


## Какая выгода от того, где будет аллоцироваться переменная?
---


Если переменная в куче, то мы будем нагружать GC очисткой кучи от этих самый переменных

Отсюда выполнение ф-ии может замедляться


Если мы передаем жирную переменную по значению, копию останется в стеке, но полностью копируются (все биты одной переменной будут скопированы по-порядку в другом месте памяти)

Это может замедлить ф-ию даже сильнее, чем аллокация в куче


## Чем стек отличается от кучи
---


![[Screenshot From 2025-10-01 18-19-21.png]]


## Устройство стека
---


На каждую горутину выделяется свой стек

Все стеки в контексте GO представляют собой стеки горутин

Стек растет по памяти **от 2КБ до 1Гб (256Мб в 32-битной системе)**

Все ф-ии, вызываемые в горутине, будут в зависимости от очереди вызова аллоцироваться в стеке горутины

![[Screenshot From 2025-10-01 18-29-15.png]]



После каждой аллокации на конце адреса ф-ии размещается **stack pointer**

Сам **frame ф-ии** хранит адрес окончания ф-ии, адрес предыдущего фрейма и локальные переменные

![[Screenshot From 2025-10-01 18-31-22.png]]



Если стек разрастется, например создастся переменная на >2Kb или вызовется рекусрия с большой глубиной, в памяти аллоцируется область под новый стек, куда копируются все фреймы в той же очереди

![[Screenshot From 2025-10-01 18-35-48.png]]





# GC
---


## Что такое сборщик мусора? Какие данные попадают под термин 'мусор'
---


GC нужен для того, чтобы освобождать память в **куче** (stack сам себя чистит) от объектов, которые больше не нужны приложению

Мусор - это объекты, на которые **никто** больше **не ссылается** (нет валидных ссылок)



Здесь в примере мы создали слайс на стеке. Сама структура у ссылочного типа (у слайса это массив) попадет в кучу, а ссылка останется на стеке

![[Screenshot From 2025-10-02 13-36-55.png]]

Если после отработки ф-ии мы не передали указатель на массив, он станет **мусорным объектом**, т.к. все указатели либо не используются дальше либо ячейки памяти с переменной указателя перетерлись


Тут ссылка все еще живет в памяти, но нигде не используется
![[Screenshot From 2025-10-02 13-39-59.png]]


А здесь указатель перетерся другой ф-ей
![[Screenshot From 2025-10-02 13-43-07.png]]


## Как работает GC (для ознакомительного вопроса)
---


GC работает по алгоритму `Concurrent mark & sweep`

Он трехцветный, т.е. у объектов может быть 3 цвета при разметке:

- белый
- серый
- черный


Работа алгоритма состоит из 2 фаз:

- Фаза разметки Aka `Sweep termination` (STW)
  
![[Screenshot From 2025-10-02 14-03-23.png]]


- Фаза очистки, которая возобновляет работу программы, GC не работает уже  
 ![[Screenshot From 2025-10-02 14-05-16.png]]


## Когда запускается GC?
---


GC запускается в нескольких случаях:

- Когда память в **куче** заполняется до о**пределенного значения** по **специальной формуле**, которая зависит от параметров `GOGC` и `MEMLIMIT`

- Планировщиком **раз в 2 минуты**
  
- Можно запустить вручную через библиотеку `runtime`


> [!important] 
> Важные факты о работе GC:
> 
> - GC работает **конкурентно** с приложением, т.е. он не прервет выполнение прграммы
> 
> - GC забирает **25%** ресурсов CPU себе (из 4 лог. ядер забирает 1 и т.д.)
> 
> - Работающие горутины могут быть привлечены на помощь к работе GC.
> 	
> 	По факту вместо аллокации памяти они будут заниматься **разметкой объектов**
> 	Причем очередь горутин будут зависеть от частоты аллокаций
> >
>>
> - GC можно **отключить** через параметр `GOGC = off` (без `MEMLIMIT`!)


## Когда может потребоваться отключать GC?
---


В некоторых случаях:

- Когда приложение потребляет мало памяти (например CLI приложения)

- Мы хотим сами управлять GC

- Для тестов/профилирования


## Как работает GC (для вопроса в глубину)
---


Перед стартом GC наши объекты представляют собой такую схему

![[Screenshot From 2025-10-02 15-12-16.png]]

Рантайм GO **знает** о всех объектах в куче (он может по ним проитерироваться), но **не знает**, какие ему надо удалить

Поэтому перед удалением их надо разметить



Перед разметкой рантайм находит все ссылки на объекты в куче и кладет их в специальную очередь

![[Screenshot From 2025-10-02 15-16-36.png]]



Все объекты в куче, на которые есть ссылки, изначально помечаются **серым**

После этого рантайм рекурсивно ищет другие ссылки, которые найдет в начальной

Если такие существуют, то объект, на который указывала начальная ссылка, окрашивается **черным**, а подссылки окрашиваются **серым**

![[Screenshot From 2025-10-02 15-18-24.png]]

Черный цвет означает, что объект "живой", т.е. мы нашли на него ссылку среди стеков горутин или глобальных переменных

Все подссылки попадают **в конец очереди** 



После всего вышеперечисленного берется следующая ссылка из очереди и повторяются те же самые действия

![[Screenshot From 2025-10-02 15-29-39.png]]



**В конце разметки в куче остаются только черные и белые объекты**, причем ни один из черных не ссылается на белый

![[Screenshot From 2025-10-02 15-31-45.png]]



После разметки GC **выключается**, а оставшиеся белые объекты по мере работы программы **затираются аллокациями новых объектов на куче**

![[Screenshot From 2025-10-02 15-35-22.png]]





---


## Related


